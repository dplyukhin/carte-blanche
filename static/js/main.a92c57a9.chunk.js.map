{"version":3,"sources":["logo.jpeg","serviceWorker.ts","search.ts","model.ts","cloud.ts","components/SearchBar.tsx","util.tsx","components/NotePreview.tsx","components/NoteEditor.tsx","components/NoteViewer.tsx","components/Note.tsx","keymap.ts","components/App.tsx","index.tsx"],"names":["module","exports","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","removeFormatting","text","remark","use","RemarkMathPlugin","strip","processSync","toString","getFeatures","expandedText","contractions","expand","tokens","natural","PorterStemmer","tokenizeAndStem","vec","token","undefined","Object","keys","length","addToIndex","id","contents","index","entries","count","addVecToIndex","rankedCosineSimilarity","vec1","vec2","intersectCount","includes","numerator","cosineSimilarity","State","snapshot","db","root","currentIndexID","focus","mode","clipboard","selection","dirty","this","uuid","type","hash","slice","history","notes","Search","localStorage","setItem","JSON","stringify","prototype","hasOwnProperty","call","card","replaceState","pushState","view","back","forward","currentIndex","query","results","queryString","documents","Map","occurrences","weight","get","set","similarity","push","sort","a","b","map","newIndex","enter","save","focusedCard","search","note","update","copy","splice","indexID","endsWith","substr","updateIndex","findIndex","x","remove","lower","Math","min","upper","max","i","focusedCardID","insertAfter","timestamp","Date","now","readBlob","blob","Promise","resolve","reject","reader","FileReader","onload","evt","target","result","onerror","err","readAsText","getAccessToken","cached_token","getItem","url_token","str","ret","create","trim","replace","split","forEach","param","parts","key","shift","val","join","decodeURIComponent","val2","Array","isArray","parseQueryString","access_token","isAuthenticated","dbx","Dropbox","fetch","accessToken","clientId","filesUpload","path","mute","filesDownload","fileBlob","response","parse","Cloud","upload","download","authenticationURL","getAuthenticationUrl","SearchBar","dispatch","useState","setQuery","ref","useRef","className","onSubmit","event","preventDefault","current","blur","onChange","e","value","onKeyDown","htmlFor","scrollToElement","el","scrollIntoView","behavior","block","MarkdownRenderers","math","inlineMath","code","language","style","docco","React","memo","words","preview","source","plugins","RemarkHighlightPlugin","renderers","deserialize","setValue","editor","useMemo","withHistory","withReact","createEditor","serialize","autoFocus","placeholder","marginTop","marginBottom","n","Node","string","line","children","isFocused","isSelected","useEffect","setTimeout","position","normalModeKeymap","boundKeys","handleKey","Loading","CloudAuthentication","href","PreviewCards","App","focusedID","outgoing","incoming","keyName","src","logo","alt","Error","Note","MainCards","smoothscroll","render","ReactDOM","StrictMode","document","getElementById","action","showRelatedNotes","goBack","goForward","newNote","paste","removeSelection","goUp","goDown","updateNote","setInterval","cloudSnapshot","localSnapshot","onpopstate","URL","process","origin","addEventListener","headers","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.a92c57a9.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.743a2742.jpeg\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import RemarkMathPlugin from 'remark-math';\nimport remark from 'remark';\nimport strip from 'strip-markdown';\nimport natural from 'natural';\nimport contractions from 'expand-contractions';\nimport { ID } from './model';\n\n/** Associates each word to a number of occurrences in the corpus */\nexport type WordVector = { [key: string]: number }\n\n/**\n * Associates each card ID with the number of times a token occurs in that card.\n */\nexport type Occurrences = { [key: string]: number }\n\n/** \n * Associates each word to the set of cards that contain it\n * and the number of occurrences in that card.\n */\nexport type Index = { [key: string]: Occurrences }\n\nexport function newIndex(): Index {\n    return {};\n}\n\n/**\n * Given some markdown text, return a version of that text minus formatting.\n * @param text \n */\nexport function removeFormatting(text: string): string {\n    return remark()\n        .use(RemarkMathPlugin)\n        .use(strip)\n        .processSync(text)\n        .toString()\n}\n\n/**\n * Normalizes, tokenizes, removes stop words, and stems the given string.\n * @param text A plain text string\n */\nexport function getFeatures(text: string): WordVector {\n    const expandedText = contractions.expand(text);\n    const tokens = natural.PorterStemmer.tokenizeAndStem(expandedText);\n    const vec: WordVector = {};\n    for (const token of tokens) {\n        vec[token] = vec[token] === undefined ? 1 : vec[token] + 1;\n    }\n    // Normalize\n    for (const token of Object.keys(vec)) {\n        vec[token] = vec[token] / tokens.length\n    }\n    return vec;\n}\n\nfunction addVecToIndex(id: ID, vec: WordVector, index: Index) {\n    for (const [token, count] of Object.entries(vec)) {\n        if (index[token] === undefined) {\n            index[token] = {};\n        }\n        index[token][id] = count;\n    }\n}\n\nfunction removeVecFromIndex(id: ID, vec: WordVector, index: Index) {\n    for (const token of Object.keys(vec)) {\n        if (index[token] !== undefined) {\n            console.log(\"Deleting\", token, \"with count\", index[token][id])\n            delete index[token][id]\n        }\n    }\n}\n\nexport function addToIndex(id: ID, contents: string, index: Index) {\n    const text = removeFormatting(contents)\n    const features = getFeatures(text)\n    addVecToIndex(id, features, index);\n}\n\nexport function removeFromIndex(id: ID, contents: string, index: Index) {\n    const text = removeFormatting(contents)\n    const features = getFeatures(text)\n    removeVecFromIndex(id, features, index);\n}\n\n/**\n * Computes the similarity of two vectors v1, v2 by taking the dot product.\n * @return A number between 0 and 1; higher is more similar\n */\nfunction cosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let numerator = 0\n    // Note that we only need to iterate over the keys of *one* of the vectors\n    for (const token of Object.keys(vec1)) {\n        numerator += (vec1[token] || 0) * (vec2[token] || 0)\n    }\n    // Since we know both vectors are normalized, the denominator is 1\n    return numerator;\n}\n\n/**\n * Computes the similarity between its inputs.\n * This function is similar to `cosineSimilarity`, but we make sure that\n * a note that matches N keywords always outranks a note matching M < N keywords\n */\nfunction rankedCosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let intersectCount = 0\n    for (const token of Object.keys(vec1)) {\n        if (Object.keys(vec2).includes(token)) {\n            intersectCount += 1\n        }\n\n    }\n    return intersectCount + cosineSimilarity(vec1, vec2)\n}\n\nexport function search(queryString: string, index: Index): ID[] {\n    const query = getFeatures(queryString);\n    if (Object.keys(query).length === 0) return [];\n\n    // We now reconstruct a projection of each document's word vector, only\n    // counting the words that are already in our query.\n\n    // E.g., query = {additive: 0.5, monad: 0.5} and\n    // index = { additive: {\"doc\": 0.2, ...}, monad: {\"doc\": 0.5, ...}, ... }\n    // then documents[\"doc\"] = {additive: 0.2, monad: 0.5}.\n    const documents: Map<ID, WordVector> = new Map();\n    for (const token of Object.keys(query)) {\n        const occurrences = index[token] || {}\n        for (const [id, weight] of Object.entries(occurrences)) {\n            const vec = documents.get(id) || {};\n            vec[token] = weight;\n            documents.set(id, vec)\n        }\n    }\n    // console.log(\"Reconstructed vectors:\", documents)\n\n    // Assign each ID with a similarity score\n    const similarity: [ID, number][] = []\n    for (const [id, vec] of documents.entries()) {\n        similarity.push([id, rankedCosineSimilarity(query, vec)])\n    }\n    // Sort by score, descending\n    similarity.sort((a, b) => b[1] - a[1])\n    // console.log(\"Similarity scores:\", similarity)\n\n    return similarity.map(([id, _]) => id).slice(0, 30)\n}","import { v4 as uuid } from 'uuid';\nimport * as Search from './search';\n\nexport type ID = string\nexport type Card = Note | Index\n\nexport type Note = {\n    type: \"note\",\n    contents: string\n}\n\nexport type Index = {\n    type: \"index\",\n    contents: ID[]\n}\n\ntype Database = { [key: string]: Card }\n\nexport type Mode = 'viewing' | 'editing' | 'selecting'\n\n\nexport const DB_STRING = 'database';\n\nexport type Snapshot = {\n    db: Database,\n    root: ID,\n    timestamp: number\n}\n\nexport class State {\n    // Persistent state\n    db: Database\n    root: ID\n\n    // Temporary state\n    currentIndexID: ID\n    focus: number\n    mode: Mode\n    clipboard: ID[]\n    selection?: number\n    dirty: boolean\n    index: Search.Index\n\n    constructor(snapshot: Snapshot | null) {\n        if (snapshot === null) {\n            this.root = uuid()\n            this.db = {}\n            this.db[this.root] = { type: 'index', contents: [] }\n        }\n        else {\n            this.root = snapshot.root\n            this.db = snapshot.db\n        }\n        if (window.location.hash !== \"\") {\n            this.currentIndexID = window.location.hash.slice(1)\n            this.focus = window.history.state.focus || -1\n        }\n        else {\n            this.currentIndexID = this.root \n            this.focus = -1\n        }\n        this.mode = 'viewing'\n        this.clipboard = []\n        this.dirty = false;\n\n        // Build index\n        this.index = Search.newIndex();\n        for (const [id, note] of this.notes()) {\n            Search.addToIndex(id, note.contents, this.index);\n        }\n    }\n\n    get snapshot(): Snapshot {\n        return {\n            db: this.db,\n            root: this.root,\n            timestamp: Date.now()\n        }\n    }\n\n    save() {\n        localStorage.setItem(DB_STRING, JSON.stringify(this.snapshot))\n        console.log(\"Saved change to local storage\")\n        this.dirty = true\n    }\n\n    get currentIndex(): Index {\n        return this.db[this.currentIndexID] as Index\n    }\n    get focusedCardID(): ID | undefined {\n        // This is undefined when the focus is -1\n        return this.currentIndex.contents[this.focus]\n    }\n    get focusedCard(): Card | undefined {\n        // This is undefined when the focus is -1\n        return this.focusedCardID ? this.db[this.focusedCardID] : undefined\n    }\n    * notes(): Generator<[ID, Note]> {\n        for (const id in this.db) {\n            if (Object.prototype.hasOwnProperty.call(this.db, id)) {\n                const card = this.db[id];\n                if (card.type === 'note') {\n                    yield [id, card];\n                }\n            }\n        }\n    }\n\n    // NAVIGATION\n\n    view(id: ID, focus: number) {\n        this.currentIndexID = id;\n        this.focus = focus === undefined ? -1 : focus\n    }\n    enter(id: ID) {\n        const focus = this.db[id].contents.length > 0 ? 0 : -1;\n        window.history.replaceState({ focus: this.focus }, \"\", \"#\" + this.currentIndexID);\n        window.history.pushState({focus: focus}, \"\", \"#\" + id);\n        this.view(id, focus)\n    }\n    goBack() {\n        window.history.back()\n    }\n    goForward() {\n        window.history.forward()\n    }\n    goUp() {\n        // The behavior in 'selecting' mode and 'viewing' mode is\n        // slightly different: when selecting, you cannot move the\n        // focus any higher than 0.\n        if (this.mode === 'viewing') {\n            if (this.focus > -1) {\n                this.focus = this.focus - 1\n            }\n        }\n        if (this.mode === 'selecting') {\n            if (this.focus > 0) {\n                this.focus = this.focus - 1\n            }\n        }\n    }\n    goDown() {\n        if (this.focus < this.currentIndex.contents.length - 1) {\n            this.focus = this.focus + 1\n        }\n    }\n\n    // MUTATION\n\n    search(query: string) {\n        const results = Search.search(query, this.index)\n        const id = this.newIndex()\n        const index = this.db[id]!\n        index.contents = results\n        this.enter(id)\n        this.save()\n    }\n    showRelatedNotes() {\n        const card = this.focusedCard\n        if (card !== undefined && card.type === 'note') {\n            const text = Search.removeFormatting(card.contents)\n            this.search(text)\n        }\n    }\n    updateNote(id : ID, contents : string): boolean {\n        const note = this.db[id]\n        if (note && note.type === 'note') {\n            this.db[id] = {...note, contents}\n            return true\n        }\n        else {\n            return false\n        }\n    }\n    /** Helper method for updating indexes immutably.\n     * Passes a deep copy of the index with ID `id` to the `update` function\n     * then stores the new object back in the database.\n     */\n    updateIndex(id: ID, update: (index: Index) => void) {\n        const note: Index = this.db[id] as Index\n        const copy: Index = { type: 'index', contents: note.contents.slice() }\n        update(copy)\n        this.db[id] = copy\n    }\n    insertAfter(focus: number, id: ID) {\n        this.currentIndex.contents.splice(focus + 1, 0, id)\n\n        // If this note is added to the outgoing links of another\n        // note, then add the latter to the *incoming* links of the former.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-incoming\", (index) => {\n                index.contents.push(note)\n            })\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-outgoing\", (index) => {\n                index.contents.push(note)\n            })\n        }\n        this.save()\n    }\n    remove(focus: number) {\n        const id = this.currentIndex.contents[focus]\n\n        // Remove the focused element from the index\n        this.updateIndex(this.currentIndexID, (index) => {\n            index.contents.splice(focus, 1)\n        })\n\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n\n        // If this note was deleted from the outgoing links of\n        // another note, then we should also remove that note\n        // from the incoming links of this note.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-incoming\", (index) => {\n                const focus = index.contents.findIndex(x => x === note)\n                index.contents.splice(focus, 1)\n            })\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-outgoing\", (index) => {\n                const focus = index.contents.findIndex(x => x === note)\n                index.contents.splice(focus, 1)\n            })\n        }\n        this.save()\n    }\n    newNote(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'note', contents: \"\"}\n        this.db[id + \"-incoming\"] = {type: 'index', contents: []}\n        this.db[id + \"-outgoing\"] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    newIndex(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    removeSelection() {\n        if (this.mode === 'viewing') {\n            this.remove(this.focus)\n        }\n        else if (this.mode === 'selecting') {\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            for (let i = lower; i <= upper; i++) {\n                // Delete the lowest index, and the next note\n                // to delete will be moved to that element. \n                this.remove(lower);\n            }\n            this.mode = 'viewing'\n            this.selection = undefined\n            this.focus = lower\n        }\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n    }\n    copy() {\n        if (this.mode === 'viewing') {\n            this.clipboard = [this.focusedCardID!]\n        }\n        else if (this.mode === 'selecting') {\n            const index = this.currentIndex\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            this.clipboard = []\n            for (let i = lower; i <= upper; i++) {\n                this.clipboard.push(index.contents[i])\n            }\n        }\n    }\n    paste() {\n        for (let i = 0; i < this.clipboard.length; i++) {\n            this.insertAfter(this.focus + i, this.clipboard[i])\n        }\n    }\n}","import fetch from \"isomorphic-fetch\";\nimport { Dropbox } from \"dropbox\";\nimport { State, Snapshot } from \"./model\";\n\n/**\n * This code is based on the dropbox API examples:\n * https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/auth/index.html\n */\n\nconst DROPBOX_APP_KEY = \"31ybvx3rsag1cih\";\nconst CLOUD_PATH = \"/database.json\";\nconst ACCESS_TOKEN_COOKIE = \"dropbox_access_token\"\n\n// SOURCE: https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/utils.js\nfunction parseQueryString(str: string) {\n    var ret = Object.create(null);\n\n    if (typeof str !== \"string\") {\n        return ret;\n    }\n\n    str = str.trim().replace(/^(\\?|#|&)/, \"\");\n\n    if (!str) {\n        return ret;\n    }\n\n    str.split(\"&\").forEach(function (param) {\n        var parts = param.replace(/\\+/g, \" \").split(\"=\");\n        // Firefox (pre 40) decodes `%3D` to `=`\n        // https://github.com/sindresorhus/query-string/pull/37\n        var key = parts.shift();\n        var val = parts.length > 0 ? parts.join(\"=\") : undefined;\n\n        key = decodeURIComponent(key!);\n\n        // missing `=` should be `null`:\n        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n        var val2 = val === undefined ? null : decodeURIComponent(val);\n\n        if (ret[key] === undefined) {\n            ret[key] = val2;\n        } else if (Array.isArray(ret[key])) {\n            ret[key].push(val2);\n        } else {\n            ret[key] = [ret[key], val2];\n        }\n    });\n\n    return ret;\n}\n\nfunction readBlob(blob: Blob): Promise<string | ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = function (evt) {\n            if (evt && evt.target && evt.target.result) {\n                resolve(evt.target.result);\n            } else {\n                reject(\n                    \"Blob had an unexpected format: blob.target.result is undefined\\n\" +\n                    evt\n                );\n            }\n        };\n        reader.onerror = function (err) {\n            reject(err);\n        };\n        reader.readAsText(blob);\n    });\n}\n\n// Fetch the access token from local storage, or else check if\n// it is in the URL as a result of OAuth\nfunction getAccessToken() {\n    const cached_token = localStorage.getItem(ACCESS_TOKEN_COOKIE)\n    if (cached_token !== null) {\n        return cached_token;\n    }\n\n    const url_token = parseQueryString(window.location.hash).access_token\n    if (url_token) {\n        localStorage.setItem(ACCESS_TOKEN_COOKIE, url_token)\n    }\n    return url_token\n}\n\nexport function isAuthenticated() {\n    return !!getAccessToken();\n}\n\nconst dbx = isAuthenticated()\n    ? new Dropbox({ fetch, accessToken: getAccessToken() })\n    : new Dropbox({ fetch, clientId: DROPBOX_APP_KEY });\n\nasync function upload(state: State): Promise<void> {\n    try {\n        state.dirty = false;\n        const result = await dbx.filesUpload({\n            contents: JSON.stringify(state.snapshot),\n            path: CLOUD_PATH,\n            mode: { \".tag\": \"overwrite\" },\n            mute: true,\n        })\n        console.log(\"Upload successful\");\n        console.log(result);\n    }\n    catch (e) {\n        console.error(\"Upload failed!\");\n        console.error(e);\n        state.dirty = true;\n    }\n}\n\nasync function download(): Promise<Snapshot | null> {\n    try {\n        const result = await dbx.filesDownload({ path: CLOUD_PATH }) as any;\n        const response = await readBlob(result.fileBlob) as string\n        const snapshot = JSON.parse(response) as Snapshot;\n        return snapshot;\n    } catch (err) {\n        console.error(\"Error fetching data from cloud:\");\n        console.error(err);\n        return null;\n    }\n}\n\nexport type AuthenticatedCloud = {\n    isAuthenticated: true,\n    upload: (state: State) => Promise<void>,\n    download: () => Promise<Snapshot | null>\n}\n\nexport type UnauthenticatedCloud = {\n    isAuthenticated: false,\n    authenticationURL: string\n}\n\nexport type Cloud = AuthenticatedCloud | UnauthenticatedCloud\n\nconst Cloud: Cloud = isAuthenticated() ?\n    {\n        isAuthenticated: true,\n        upload, download\n    }\n    :\n    {\n        isAuthenticated: false,\n        authenticationURL: dbx.getAuthenticationUrl(window.location.toString())\n    }\n\nexport default Cloud\n\n\n","import React, { useRef, useState } from \"react\";\nimport { Action } from \"../actions\";\n\nexport type Props = {\n    dispatch(action: Action): void\n}\n\nexport default function SearchBar({ dispatch }: Props): JSX.Element {\n    const [query, setQuery] = useState(\"\");\n    const ref: React.MutableRefObject<HTMLInputElement | null> = useRef(null)\n\n    function onSubmit(event: React.SyntheticEvent) {\n        event.preventDefault()\n        dispatch({ type: 'search', query })\n        if (ref.current) ref.current.blur()\n    }\n\n    function onKeyDown(e: React.KeyboardEvent) {\n        if (e.key === 'Escape') {\n            if (ref.current) ref.current.blur()\n        }\n    }\n\n    return (\n        <form className=\"input-field\" onSubmit={onSubmit}>\n            <i className=\"material-icons prefix\">search</i>\n            <input id=\"icon_prefix\" type=\"text\" ref={ref}\n                onChange={e => setQuery(e.target.value)}\n                onKeyDown={onKeyDown} />\n            <label htmlFor=\"icon_prefix\">Search</label>\n        </form>\n    )\n}","import React from 'react';\nimport ReactMarkdown from \"react-markdown\"\nimport { BlockMath, InlineMath } from 'react-katex';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\nexport function scrollToElement(el: HTMLElement) {\n    el.scrollIntoView({ behavior: \"smooth\", block: \"center\" })\n}\n\nexport const MarkdownRenderers: ReactMarkdown.Renderers = {\n    math: ({ value }) => <BlockMath>{value}</BlockMath>,\n    inlineMath: ({ value }) => <InlineMath>{value}</InlineMath>,\n    code: ({ language, value }) => <SyntaxHighlighter language={language} style={docco}>{value}</SyntaxHighlighter>\n}","import React from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport RemarkMathPlugin from 'remark-math';\nimport RemarkHighlightPlugin from 'remark-highlight.js';\nimport { Card } from \"../model\";\nimport { MarkdownRenderers } from \"../util\";\n\ntype Props = {\n    card: Card,\n}\n\nexport default React.memo(({ card }: Props): JSX.Element => {\n    if (card.type === 'index') {\n        return (\n            <div className=\"card-panel truncate\">\n                {`Index: (${card.contents.length} cards)`}\n            </div>\n        )\n    }\n    else {\n        const words = card.contents.split(\" \");\n        const preview = words.length > 20\n            ? words.slice(0, 20).join(\" \") + \"...\"\n            : card.contents;\n\n        return (\n            <div className=\"card-panel\">\n                <ReactMarkdown\n                    source={preview}\n                    plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n                    renderers={MarkdownRenderers as any}\n                />\n            </div>\n        )\n    }\n})","import React, { useMemo, useRef, useState } from 'react'\nimport { createEditor, Node } from 'slate'\nimport { Slate, Editable, withReact } from 'slate-react'\nimport { withHistory } from 'slate-history'\nimport { Action } from '../actions'\nimport { ID, Note } from '../model'\nimport { scrollToElement } from '../util'\n\nexport type Props = {\n    id: ID,\n    note: Note,\n    dispatch(action: Action): void,\n}\n\nexport default React.memo((\n    { note, id, dispatch }: Props\n): JSX.Element => {\n\n    const ref: React.MutableRefObject<HTMLTextAreaElement | null> = useRef(null)\n\n    if (ref.current)\n        scrollToElement(ref.current)\n\n    function onKeyDown(e: React.KeyboardEvent) {\n        if (e.key === 'Escape') {\n            dispatch({ type: 'stop editing' })\n\n        }\n    }\n\n    const [value, setValue] = useState<Node[]>(deserialize(note.contents))\n    const editor = useMemo(() => withHistory(withReact(createEditor())), [])\n\n    function onChange(value: Node[]) {\n        setValue(value)\n        dispatch({ type: 'update note', id, contents: serialize(value) })\n    }\n\n    return (\n        <div className=\"card-panel z-depth-3 edited-note\">\n            <Slate editor={editor} value={value} onChange={onChange}>\n                <Editable autoFocus\n                    onKeyDown={onKeyDown}\n                    placeholder=\"Enter some text...\"\n                    style={{ marginTop: '14px', marginBottom: '14px' }}\n                />\n            </Slate>\n        </div>\n    )\n})\n\n// Define a serializing function that takes a value and returns a string.\nconst serialize = (value: Node[]) => {\n    return (\n        value\n            // Return the string content of each paragraph in the value's children.\n            .map(n => Node.string(n))\n            // Join them all with line breaks denoting paragraphs.\n            .join('\\n')\n    )\n}\n\n// Define a deserializing function that takes a string and returns a value.\nconst deserialize = (string: any): Node[] => {\n    // Return a value array of children derived by splitting the string.\n    return string.split('\\n').map((line: string) => {\n        return {\n            children: [{ text: line }],\n        }\n    })\n}","import React, { useEffect, useRef } from \"react\";\nimport ReactMarkdown from \"react-markdown\";\nimport { ID, Note } from \"../model\";\nimport { scrollToElement } from \"../util\";\nimport RemarkMathPlugin from 'remark-math';\nimport RemarkHighlightPlugin from 'remark-highlight.js';\nimport { MarkdownRenderers } from \"../util\";\n\ntype Props = {\n    card: Note,\n    id: ID,\n    isFocused: boolean,\n    isSelected: boolean\n}\n\nexport default React.memo((\n    { card, id, isFocused, isSelected }: Props\n): JSX.Element => {\n\n    const ifFocused = isFocused ? \"z-depth-3\" : \"\";\n    const ifSelected = isSelected ? \"blue lighten-5\" : \"\";\n    const className = [\"card-panel\", ifFocused, ifSelected].join(\" \");\n\n    const ref: React.MutableRefObject<HTMLDivElement | null> = useRef(null)\n\n    useEffect(() => {\n        const el = ref.current\n        if (el && isFocused) {\n            console.log(\"Scrolling to\", id);\n\n            setTimeout(() => {\n                scrollToElement(el)\n            }, 20)\n        }\n    })\n\n    return (\n        <div className={className} ref={ref}>\n            <ReactMarkdown\n                source={card.contents}\n                plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n                renderers={MarkdownRenderers as any}\n            />\n        </div>\n    )\n})","import React from \"react\"\nimport { Action } from \"../actions\"\nimport { ID, Mode, Note } from \"../model\"\nimport EditNote from \"./NoteEditor\"\nimport ViewNote from \"./NoteViewer\"\n\n\ntype Props = {\n    id: ID,\n    card: Note,\n    position: number,\n    focus: number,\n    selection?: number,\n    mode: Mode,\n    dispatch(action: Action): void\n}\n\nexport default React.memo((\n    { id, card, position, focus, selection, mode, dispatch }: Props\n): JSX.Element => {\n\n    const isFocused = focus === position\n    const isSelected = mode === 'selecting' &&\n        ((focus <= position && position <= selection!) ||\n            (focus >= position && position >= selection!))\n\n    if (isFocused && mode === 'editing') {\n        return (\n            <EditNote note={card} id={id} dispatch={dispatch} />\n        )\n    }\n    else {\n        return (\n            <ViewNote card={card} id={id} isFocused={isFocused} isSelected={isSelected} />\n        )\n    }\n})","import { Action } from \"./actions\"\n\nconst normalModeKeymap : { [key: string] : Action} = {\n    'Enter':           {type: 'edit'},\n    'command+c':       {type: 'copy'},\n    'command+x':       {type: 'cut'},\n    'command+v':       {type: 'paste'},\n    'command+z':       {type: 'undo'},\n    'command+shift+z': {type: 'redo'},\n    'Space':           {type: 'new note'},\n    'right':           {type: 'right'},\n    'left':            {type: 'left'},\n    'up':              {type: 'up'},\n    'down':            {type: 'down'},\n    'Escape':          {type: 'back'},\n    'Backspace':       {type: 'remove'},\n    'shift+down':      {type: 'select and go down'},\n    'shift+up':        {type: 'select and go up'},\n    'shift+f':         {type: 'find related notes'},\n    // VIM keybindings\n    'j':               {type: 'down'},\n    'k':               {type: 'up'},\n    'h':               {type: 'left'},\n    'l':               {type: 'right'},\n    'shift+h':         {type: 'back'},\n    'shift+l':         {type: 'forward'},\n    'u':               {type: 'undo'},\n    'ctrl+r':          {type: 'redo'},\n    'y':               {type: 'copy'},\n    'p':               {type: 'paste'},\n    'x':               {type: 'cut'},\n    'd':               {type: 'remove'},\n    'i':               {type: 'edit'},\n    'a':               {type: 'new note'},\n}\n\nexport const boundKeys = Object.keys(normalModeKeymap).join(\",\")\n  \n\nexport const handleKey = (dispatch: (a: Action) => void) => (key: string, event: any) => {\n    // Prevent the default refresh event under WINDOWS system\n    event.preventDefault() \n    console.log(normalModeKeymap[key]) \n    dispatch(normalModeKeymap[key])\n}; ","import React from 'react';\nimport Hotkeys from 'react-hot-keys';\nimport logo from '../logo.jpeg';\nimport SearchBar from './SearchBar';\nimport CardPreview from './NotePreview';\nimport Note from './Note';\nimport Dropbox from '../cloud';\nimport { ID, Index, State } from '../model';\nimport { Action } from '../actions';\nimport { boundKeys, handleKey } from '../keymap';\n\n\nfunction Loading(): JSX.Element {\n    return (\n        <div className=\"row\">\n            <div className=\"col s3 offset-s4\">\n                <div className=\"card-panel valign-wrapper\">\n                    <b className=\"center-align\">Loading...</b>\n                </div>\n            </div>\n        </div>\n    )\n}\n\nfunction CloudAuthentication(): JSX.Element | null {\n    return (\n        Dropbox.isAuthenticated ? null :\n            <div className=\"card-panel\">\n                <a href={Dropbox.authenticationURL}>Sign in to Dropbox</a>\n            </div>\n    )\n}\n\nfunction PreviewCards(state: State, index: Index): JSX.Element[] {\n    return (\n        index.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} />\n        })\n    )\n}\n\nfunction MainCards(state: State, dispatch: (action: Action) => void): JSX.Element[] {\n    return (\n        state.currentIndex.contents.map(function (id: ID, i: number) {\n\n            const card = state.db[id]\n            if (card.type !== 'note')\n                throw Error(\"I only know how to render notes\")\n\n            return <Note key={i} id={id} position={i}\n                mode={state.mode} focus={state.focus} selection={state.selection}\n                card={card} dispatch={dispatch}\n            />;\n        })\n    )\n}\n\ntype Props = {\n    state: State | null,\n    dispatch(action: Action): void\n}\n\nexport default function App({ state, dispatch }: Props): JSX.Element {\n\n    if (state === null) {\n        return <Loading />\n    }\n\n    const focusedID = state.currentIndex.contents[state.focus]\n    const outgoing = state.db[focusedID + \"-outgoing\"] as Index | undefined\n    const incoming = state.db[focusedID + \"-incoming\"] as Index | undefined\n\n    return (\n        <Hotkeys\n            keyName={boundKeys}\n            onKeyDown={handleKey(dispatch)}\n        >\n            <div className=\"row\">\n                <div id=\"left-panel\" className=\"pinned col l3 offset-l1 m3 hide-on-small-only\">\n                    <a href=\"/\"><img id=\"logo\" src={logo} alt=\"Go home\" /></a>\n                    {incoming && PreviewCards(state, incoming)}\n                </div>\n                <div id=\"main-panel\" className=\"col l4 offset-l4 m6 offset-m3 s10 offset-s1\">\n                    <SearchBar dispatch={dispatch} />\n                    <CloudAuthentication />\n                    {MainCards(state, dispatch)}\n                </div>\n                <div id=\"right-panel\" className=\"pinned col l3 offset-l8 m3 offset-m9 hide-on-small-only\">\n                    {outgoing && PreviewCards(state, outgoing)}\n                </div>\n            </div>\n        </Hotkeys>\n    )\n}","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.scss';\nimport * as serviceWorker from './serviceWorker';\nimport { State, Snapshot, DB_STRING } from './model';\nimport 'materialize-css/dist/js/materialize.min.js';\nimport 'katex/dist/katex.min.css';\nimport Dropbox, { AuthenticatedCloud } from './cloud';\nimport * as smoothscroll from 'seamless-scroll-polyfill';\nimport { Action } from './actions';\nimport App from './components/App';\nsmoothscroll.polyfill();\n\n\nlet state: State | null = null;\n\n// Periodically upload state to Dropbox\n\nif (Dropbox.isAuthenticated) {\n    setInterval(() => {\n        if (state !== null && state.dirty)\n            (Dropbox as AuthenticatedCloud).upload(state)\n    }, 10000)\n}\n\n\n// Initialize state, checking Dropbox and localStorage\n\n(async function () {\n    const cloudSnapshot = Dropbox.isAuthenticated ? await Dropbox.download() : null\n    cloudSnapshot && console.log(\"Got cloud snapshot:\", cloudSnapshot)\n\n    const text = localStorage.getItem(DB_STRING)\n    const localSnapshot = text ? JSON.parse(text) as Snapshot : null\n    console.log(\"Got snapshot from localstorage:\", localSnapshot)\n\n    // No previous work found... Start in the initial state.\n    if (localSnapshot === null && cloudSnapshot === null) {\n        state = new State(null);\n    }\n    // Cloud backup found, with no local save. Must be logging in on a new browser or cleared the cache.\n    else if (localSnapshot === null && cloudSnapshot !== null) {\n        state = new State(cloudSnapshot);\n    }\n    // If a local copy is found with no cloud backup, then load that local state.\n    else if (localSnapshot !== null && cloudSnapshot === null) {\n        state = new State(localSnapshot);\n    }\n    // At this point we know that both a local snapshot and a cloud snapshot exist.\n    // Load whichever one has the more recent time stamp.\n    else {\n        state = (localSnapshot!.timestamp < cloudSnapshot!.timestamp)\n            ? new State(cloudSnapshot)\n            : new State(localSnapshot);\n    }\n\n    render();\n\n})()\n\n\nfunction render() {\n    ReactDOM.render(\n        <React.StrictMode>\n            <App state={state} dispatch={dispatch} />\n        </React.StrictMode>,\n        document.getElementById('root')\n    );\n}\n\nwindow.onpopstate = function (e: PopStateEvent) {\n    console.log(\"Entered index \" + window.location.hash + \" focus \" + e.state.focus)\n    if (state) {\n        state.view(window.location.hash.slice(1), e.state.focus)\n        render()\n    }\n}\n\nfunction dispatch(action: Action) {\n    if (state === null) return\n\n    if (action.type === 'search') {\n        state.search(action.query)\n    }\n\n    if (state.mode === 'viewing') {\n        if (action.type === 'edit' && state.focus >= 0) {\n            state.mode = 'editing'\n        }\n        else if (action.type === 'find related notes' && state.focus >= 0) {\n            state.showRelatedNotes()\n        }\n        else if (action.type === 'back') {\n            state.goBack()\n        }\n        else if (action.type === 'forward') {\n            state.goForward()\n        }\n        else if (action.type === 'new note') {\n            const note = state.newNote()\n            state.insertAfter(state.focus, note)\n            state.focus = state.focus + 1\n            state.mode = 'editing'\n        }\n        else if (action.type === 'paste') {\n            state.paste()\n        }\n        else if (action.type === 'right' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-outgoing')\n        }\n        else if (action.type === 'left' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-incoming')\n        }\n    }\n    if (state.mode === 'viewing' || state.mode === 'selecting') {\n        if (action.type === 'remove' && state.focus >= 0) {\n            state.removeSelection()\n        }\n        else if (action.type === 'copy' && state.focus >= 0) {\n            state.copy()\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (action.type === 'cut' && state.focus >= 0) {\n            state.copy()\n            state.removeSelection()\n        }\n        else if (action.type === 'back') {\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (action.type === 'up') {\n            state.goUp()\n        }\n        else if (action.type === 'down') {\n            state.goDown()\n        }\n        else if (action.type === 'select and go down' && state.focus >= 0) {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goDown()\n        }\n        else if (action.type === 'select and go up') {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goUp()\n        }\n    }\n    if (state.mode === 'editing') {\n        if (action.type === 'stop editing') {\n            state.mode = 'viewing'\n            state.save()\n        }\n        else if (action.type === 'update note') {\n            const result = state.updateNote(action.id, action.contents)\n\n            if (!result)\n                console.error(`Cannot update card ${action.id}: not a note`)\n        }\n    }\n\n    console.log(state)\n    render()\n}\n\nrender()\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();"],"sourceRoot":""}