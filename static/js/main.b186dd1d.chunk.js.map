{"version":3,"sources":["logo.jpeg","serviceWorker.ts","search.ts","model.ts","NoteEditor.tsx","cloud.ts","index.tsx"],"names":["module","exports","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","removeFormatting","text","remark","use","RemarkMathPlugin","strip","processSync","toString","getFeatures","expandedText","contractions","expand","tokens","natural","PorterStemmer","tokenizeAndStem","vec","token","undefined","Object","keys","length","addToIndex","id","contents","index","entries","count","addVecToIndex","rankedCosineSimilarity","vec1","vec2","intersectCount","includes","numerator","cosineSimilarity","State","snapshot","db","root","currentIndexID","focus","mode","clipboard","selection","dirty","this","uuid","type","hash","slice","history","notes","Search","localStorage","setItem","JSON","stringify","prototype","hasOwnProperty","call","card","replaceState","pushState","view","back","forward","currentIndex","query","results","queryString","documents","Map","occurrences","weight","get","set","similarity","push","sort","a","b","map","newIndex","enter","save","focusedCard","search","note","update","copy","splice","indexID","endsWith","substr","updateIndex","findIndex","x","remove","lower","Math","min","upper","max","i","focusedCardID","insertAfter","timestamp","Date","now","serialize","value","n","Node","string","join","deserialize","split","line","children","NoteEditor","props","useState","setValue","editor","useMemo","withHistory","withReact","createEditor","onChange","updateNote","autoFocus","onKeyDown","placeholder","style","marginTop","marginBottom","readBlob","blob","Promise","resolve","reject","reader","FileReader","onload","evt","target","result","onerror","err","readAsText","getAccessToken","cached_token","getItem","url_token","str","ret","create","trim","replace","forEach","param","parts","key","shift","val","decodeURIComponent","val2","Array","isArray","parseQueryString","access_token","isAuthenticated","dbx","Dropbox","fetch","accessToken","clientId","filesUpload","path","mute","filesDownload","fileBlob","response","parse","Cloud","upload","download","authenticationURL","getAuthenticationUrl","e","render","scrollToElement","el","scrollIntoView","behavior","block","smoothscroll","EditNote","React","memo","ref","useRef","current","className","MarkdownRenderers","math","inlineMath","code","language","docco","ViewNote","isFocused","isSelected","useEffect","setTimeout","source","plugins","RemarkHighlightPlugin","renderers","RenderCard","CardPreview","words","preview","setQuery","onSubmit","event","preventDefault","blur","htmlFor","Editor","cards","focusedID","outgoing","incoming","href","src","logo","alt","keymap","boundKeys","App","keyName","handleKey","showRelatedNotes","goBack","goForward","newNote","paste","removeSelection","goUp","goDown","interpretKeypress","ReactDOM","StrictMode","document","getElementById","setInterval","cloudSnapshot","localSnapshot","onpopstate","URL","process","origin","addEventListener","headers","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.b186dd1d.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.743a2742.jpeg\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import RemarkMathPlugin from 'remark-math';\nimport remark from 'remark';\nimport strip from 'strip-markdown';\nimport natural from 'natural';\nimport contractions from 'expand-contractions';\nimport { ID } from './model';\n\n/** Associates each word to a number of occurrences in the corpus */\nexport type WordVector = { [key: string]: number }\n\n/**\n * Associates each card ID with the number of times a token occurs in that card.\n */\nexport type Occurrences = { [key: string]: number }\n\n/** \n * Associates each word to the set of cards that contain it\n * and the number of occurrences in that card.\n */\nexport type Index = { [key: string]: Occurrences }\n\nexport function newIndex(): Index {\n    return {};\n}\n\n/**\n * Given some markdown text, return a version of that text minus formatting.\n * @param text \n */\nexport function removeFormatting(text: string): string {\n    return remark()\n        .use(RemarkMathPlugin)\n        .use(strip)\n        .processSync(text)\n        .toString()\n}\n\n/**\n * Normalizes, tokenizes, removes stop words, and stems the given string.\n * @param text A plain text string\n */\nexport function getFeatures(text: string): WordVector {\n  const expandedText = contractions.expand(text);\n  const tokens = natural.PorterStemmer.tokenizeAndStem(expandedText);\n  const vec: WordVector = {};\n  for (const token of tokens) {\n      vec[token] = vec[token] === undefined ? 1 : vec[token] + 1;\n  }\n  // Normalize\n  for (const token of Object.keys(vec)) {\n      vec[token] = vec[token] / tokens.length\n  }\n  return vec;\n}\n\nfunction addVecToIndex(id: ID, vec: WordVector, index: Index) {\n    for (const [token, count] of Object.entries(vec)) {\n        if (index[token] === undefined) {\n            index[token] = {};\n        }\n        index[token][id] = count;\n    }\n}\n\nfunction removeVecFromIndex(id: ID, vec: WordVector, index: Index) {\n    for (const token of Object.keys(vec)) {\n        if (index[token] !== undefined) {\n            console.log(\"Deleting\", token, \"with count\", index[token][id])\n            delete index[token][id]\n        }\n    }\n}\n\nexport function addToIndex(id: ID, contents: string, index: Index) {\n    const text = removeFormatting(contents)\n    const features = getFeatures(text)\n    addVecToIndex(id, features, index);\n}\n\nexport function removeFromIndex(id: ID, contents: string, index: Index) {\n    const text = removeFormatting(contents)\n    const features = getFeatures(text)\n    removeVecFromIndex(id, features, index);\n}\n\n/**\n * Computes the similarity of two vectors v1, v2 by taking the dot product.\n * @return A number between 0 and 1; higher is more similar\n */\nfunction cosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let numerator = 0\n    // Note that we only need to iterate over the keys of *one* of the vectors\n    for (const token of Object.keys(vec1)) {\n        numerator += (vec1[token] || 0) * (vec2[token] || 0)\n    } \n    // Since we know both vectors are normalized, the denominator is 1\n    return numerator;\n}\n\n/**\n * Computes the similarity between its inputs.\n * This function is similar to `cosineSimilarity`, but we make sure that\n * a note that matches N keywords always outranks a note matching M < N keywords\n */\nfunction rankedCosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let intersectCount = 0\n    for (const token of Object.keys(vec1)) {\n        if (Object.keys(vec2).includes(token)) {\n            intersectCount += 1\n        }\n\n    }\n    return intersectCount + cosineSimilarity(vec1, vec2)\n}\n\nexport function search(queryString: string, index: Index): ID[] {\n    const query = getFeatures(queryString);\n    if (Object.keys(query).length === 0) return [];\n\n    // We now reconstruct a projection of each document's word vector, only\n    // counting the words that are already in our query.\n\n    // E.g., query = {additive: 0.5, monad: 0.5} and\n    // index = { additive: {\"doc\": 0.2, ...}, monad: {\"doc\": 0.5, ...}, ... }\n    // then documents[\"doc\"] = {additive: 0.2, monad: 0.5}.\n    const documents: Map<ID, WordVector> = new Map();\n    for (const token of Object.keys(query)) {\n        const occurrences = index[token] || {}\n        for (const [id, weight] of Object.entries(occurrences)) {\n            const vec = documents.get(id) || {};\n            vec[token] = weight;\n            documents.set(id, vec)\n        }\n    }\n    // console.log(\"Reconstructed vectors:\", documents)\n\n    // Assign each ID with a similarity score\n    const similarity: [ID, number][] = []\n    for (const [id, vec] of documents.entries()) {\n        similarity.push([id, rankedCosineSimilarity(query, vec)])\n    }\n    // Sort by score, descending\n    similarity.sort((a,b) => b[1] - a[1])\n    // console.log(\"Similarity scores:\", similarity)\n\n    return similarity.map(([id, _]) => id).slice(0,30)\n}","import { v4 as uuid } from 'uuid';\nimport * as Search from './search';\n\nexport type ID = string\nexport type Card = Note | Index\n\nexport type Note = {\n    type: \"note\",\n    contents: string\n}\n\nexport type Index = {\n    type: \"index\",\n    contents: ID[]\n}\n\ntype Database = { [key: string]: Card }\n\nexport type Keypress \n    = 'enter' | 'escape' | 'space' | 'shift+space' | 'backspace'\n    | 'left' | 'right' | 'up' | 'down' | 'back' | 'forward'\n    | 'copy' | 'paste' | 'cut' | 'undo' | 'redo'\n    | 'shift+down' | 'shift+up'\n    | 'find'\n\nexport type Mode = 'viewing' | 'editing' | 'selecting'\n\nexport function interpretKeypress(key: Keypress, state: State) {\n    if (state.mode === 'viewing') {\n        if (key === 'enter' && state.focus >= 0) {\n            state.mode = 'editing'\n        }\n        else if (key === 'find' && state.focus >= 0) {\n            state.showRelatedNotes()\n        }\n        else if (key === 'back') {\n            state.goBack()\n        }\n        else if (key === 'forward') {\n            state.goForward()\n        }\n        else if (key === 'space') {\n            const note = state.newNote()\n            state.insertAfter(state.focus, note)\n            state.focus = state.focus + 1\n            state.mode = 'editing'\n        }\n        else if (key === 'paste') {\n            state.paste()\n        }\n        else if (key === 'right' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-outgoing')\n        }\n        else if (key === 'left' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-incoming')\n        }\n    }\n    if (state.mode === 'viewing' || state.mode === 'selecting') {\n        if (key === 'backspace' && state.focus >= 0) {\n            state.removeSelection()\n        }\n        else if (key === 'copy' && state.focus >= 0) {\n            state.copy()\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (key === 'cut' && state.focus >= 0) {\n            state.copy()\n            state.removeSelection()\n        }\n        else if (key === 'escape') {\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (key === 'up') {\n            state.goUp()\n        }\n        else if (key === 'down') {\n            state.goDown()\n        }\n        else if (key === 'shift+down' && state.focus >= 0) {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goDown()\n        }\n        else if (key === 'shift+up') {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goUp()\n        }\n    }\n    if (state.mode === 'editing') {\n        if (key === 'escape') {\n            state.mode = 'viewing'\n        }\n    }\n}\n\nexport const DB_STRING = 'database';\n\nexport type Snapshot = {\n    db: Database,\n    root: ID,\n    timestamp: number\n}\n\nexport class State {\n    // Persistent state\n    db: Database\n    root: ID\n\n    // Temporary state\n    currentIndexID: ID\n    focus: number\n    mode: Mode\n    clipboard: ID[]\n    selection?: number\n    dirty: boolean\n    index: Search.Index\n\n    constructor(snapshot: Snapshot | null) {\n        if (snapshot === null) {\n            this.root = uuid()\n            this.db = {}\n            this.db[this.root] = { type: 'index', contents: [] }\n        }\n        else {\n            this.root = snapshot.root\n            this.db = snapshot.db\n        }\n        if (window.location.hash !== \"\") {\n            this.currentIndexID = window.location.hash.slice(1)\n            this.focus = window.history.state.focus || -1\n        }\n        else {\n            this.currentIndexID = this.root \n            this.focus = -1\n        }\n        this.mode = 'viewing'\n        this.clipboard = []\n        this.dirty = false;\n\n        // Build index\n        this.index = Search.newIndex();\n        for (const [id, note] of this.notes()) {\n            Search.addToIndex(id, note.contents, this.index);\n        }\n    }\n\n    get snapshot(): Snapshot {\n        return {\n            db: this.db,\n            root: this.root,\n            timestamp: Date.now()\n        }\n    }\n\n    save() {\n        localStorage.setItem(DB_STRING, JSON.stringify(this.snapshot))\n        console.log(\"Saved change to local storage\")\n        this.dirty = true\n    }\n\n    get currentIndex(): Index {\n        return this.db[this.currentIndexID] as Index\n    }\n    get focusedCardID(): ID | undefined {\n        // This is undefined when the focus is -1\n        return this.currentIndex.contents[this.focus]\n    }\n    get focusedCard(): Card | undefined {\n        // This is undefined when the focus is -1\n        return this.focusedCardID ? this.db[this.focusedCardID] : undefined\n    }\n    * notes(): Generator<[ID, Note]> {\n        for (const id in this.db) {\n            if (Object.prototype.hasOwnProperty.call(this.db, id)) {\n                const card = this.db[id];\n                if (card.type === 'note') {\n                    yield [id, card];\n                }\n            }\n        }\n    }\n\n    // NAVIGATION\n\n    view(id: ID, focus: number) {\n        this.currentIndexID = id;\n        this.focus = focus === undefined ? -1 : focus\n    }\n    enter(id: ID) {\n        const focus = this.db[id].contents.length > 0 ? 0 : -1;\n        window.history.replaceState({ focus: this.focus }, \"\", \"#\" + this.currentIndexID);\n        window.history.pushState({focus: focus}, \"\", \"#\" + id);\n        this.view(id, focus)\n    }\n    goBack() {\n        window.history.back()\n    }\n    goForward() {\n        window.history.forward()\n    }\n    goUp() {\n        // The behavior in 'selecting' mode and 'viewing' mode is\n        // slightly different: when selecting, you cannot move the\n        // focus any higher than 0.\n        if (this.mode === 'viewing') {\n            if (this.focus > -1) {\n                this.focus = this.focus - 1\n            }\n        }\n        if (this.mode === 'selecting') {\n            if (this.focus > 0) {\n                this.focus = this.focus - 1\n            }\n        }\n    }\n    goDown() {\n        if (this.focus < this.currentIndex.contents.length - 1) {\n            this.focus = this.focus + 1\n        }\n    }\n\n    // MUTATION\n\n    search(query: string) {\n        const results = Search.search(query, this.index)\n        const id = this.newIndex()\n        const index = this.db[id]!\n        index.contents = results\n        this.enter(id)\n        this.save()\n    }\n    showRelatedNotes() {\n        const card = this.focusedCard\n        if (card !== undefined && card.type === 'note') {\n            const text = Search.removeFormatting(card.contents)\n            this.search(text)\n        }\n    }\n    updateNote(id : ID, contents : string): boolean {\n        const note = this.db[id]\n        if (note && note.type === 'note') {\n            this.db[id] = {...note, contents}\n            return true\n        }\n        else {\n            return false\n        }\n    }\n    /** Helper method for updating indexes immutably.\n     * Passes a deep copy of the index with ID `id` to the `update` function\n     * then stores the new object back in the database.\n     */\n    updateIndex(id: ID, update: (index: Index) => void) {\n        const note: Index = this.db[id] as Index\n        const copy: Index = { type: 'index', contents: note.contents.slice() }\n        update(copy)\n        this.db[id] = copy\n    }\n    insertAfter(focus: number, id: ID) {\n        this.currentIndex.contents.splice(focus + 1, 0, id)\n\n        // If this note is added to the outgoing links of another\n        // note, then add the latter to the *incoming* links of the former.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-incoming\", (index) => {\n                index.contents.push(note)\n            })\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-outgoing\", (index) => {\n                index.contents.push(note)\n            })\n        }\n        this.save()\n    }\n    remove(focus: number) {\n        const id = this.currentIndex.contents[focus]\n\n        // Remove the focused element from the index\n        this.updateIndex(this.currentIndexID, (index) => {\n            index.contents.splice(focus, 1)\n        })\n\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n\n        // If this note was deleted from the outgoing links of\n        // another note, then we should also remove that note\n        // from the incoming links of this note.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-incoming\", (index) => {\n                const focus = index.contents.findIndex(x => x === note)\n                index.contents.splice(focus, 1)\n            })\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n\n            this.updateIndex(id + \"-outgoing\", (index) => {\n                const focus = index.contents.findIndex(x => x === note)\n                index.contents.splice(focus, 1)\n            })\n        }\n        this.save()\n    }\n    newNote(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'note', contents: \"\"}\n        this.db[id + \"-incoming\"] = {type: 'index', contents: []}\n        this.db[id + \"-outgoing\"] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    newIndex(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    removeSelection() {\n        if (this.mode === 'viewing') {\n            this.remove(this.focus)\n        }\n        else if (this.mode === 'selecting') {\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            for (let i = lower; i <= upper; i++) {\n                // Delete the lowest index, and the next note\n                // to delete will be moved to that element. \n                this.remove(lower);\n            }\n            this.mode = 'viewing'\n            this.selection = undefined\n            this.focus = lower\n        }\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n    }\n    copy() {\n        if (this.mode === 'viewing') {\n            this.clipboard = [this.focusedCardID!]\n        }\n        else if (this.mode === 'selecting') {\n            const index = this.currentIndex\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            this.clipboard = []\n            for (let i = lower; i <= upper; i++) {\n                this.clipboard.push(index.contents[i])\n            }\n        }\n    }\n    paste() {\n        for (let i = 0; i < this.clipboard.length; i++) {\n            this.insertAfter(this.focus + i, this.clipboard[i])\n        }\n    }\n}","import React, { useMemo, useState } from 'react'\nimport { createEditor, Node } from 'slate'\nimport { Slate, Editable, withReact } from 'slate-react'\nimport { withHistory } from 'slate-history'\nimport { Note, ID } from './model'\n\ntype Props = { \n  note: Note, \n  id: ID, \n  updateNote: (id : ID, contents : string) => void,\n  onKeyDown: (e: React.KeyboardEvent) => void\n}\nconst NoteEditor = (props: Props) => {\n  const [value, setValue] = useState<Node[]>(deserialize(props.note.contents))\n  const editor = useMemo(() => withHistory(withReact(createEditor())), [])\n\n  function onChange(value: Node[]) {\n    setValue(value)\n    props.updateNote(props.id, serialize(value))\n  }\n\n  return (\n    <Slate editor={editor} value={value} onChange={onChange}>\n      <Editable autoFocus \n        onKeyDown={props.onKeyDown} \n        placeholder=\"Enter some text...\" \n        style={{marginTop: '14px', marginBottom: '14px'}}\n      />\n    </Slate>\n  )\n}\n\n// Define a serializing function that takes a value and returns a string.\nconst serialize = (value: Node[]) => {\n  return (\n    value\n      // Return the string content of each paragraph in the value's children.\n      .map(n => Node.string(n))\n      // Join them all with line breaks denoting paragraphs.\n      .join('\\n')\n  )\n}\n\n// Define a deserializing function that takes a string and returns a value.\nconst deserialize = (string: any): Node[] => {\n  // Return a value array of children derived by splitting the string.\n  return string.split('\\n').map((line: string) => {\n    return {\n      children: [{ text: line }],\n    }\n  })\n}\n\nexport default NoteEditor","import fetch from \"isomorphic-fetch\";\nimport { Dropbox } from \"dropbox\";\nimport { State, Snapshot } from \"./model\";\n\n/**\n * This code is based on the dropbox API examples:\n * https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/auth/index.html\n */\n\nconst DROPBOX_APP_KEY = \"31ybvx3rsag1cih\";\nconst CLOUD_PATH = \"/database.json\";\nconst ACCESS_TOKEN_COOKIE = \"dropbox_access_token\"\n\n// SOURCE: https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/utils.js\nfunction parseQueryString(str: string) {\n  var ret = Object.create(null);\n\n  if (typeof str !== \"string\") {\n    return ret;\n  }\n\n  str = str.trim().replace(/^(\\?|#|&)/, \"\");\n\n  if (!str) {\n    return ret;\n  }\n\n  str.split(\"&\").forEach(function (param) {\n    var parts = param.replace(/\\+/g, \" \").split(\"=\");\n    // Firefox (pre 40) decodes `%3D` to `=`\n    // https://github.com/sindresorhus/query-string/pull/37\n    var key = parts.shift();\n    var val = parts.length > 0 ? parts.join(\"=\") : undefined;\n\n    key = decodeURIComponent(key!);\n\n    // missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n    var val2 = val === undefined ? null : decodeURIComponent(val);\n\n    if (ret[key] === undefined) {\n      ret[key] = val2;\n    } else if (Array.isArray(ret[key])) {\n      ret[key].push(val2);\n    } else {\n      ret[key] = [ret[key], val2];\n    }\n  });\n\n  return ret;\n}\n\nfunction readBlob(blob: Blob): Promise<string | ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = function (evt) {\n        if (evt && evt.target && evt.target.result) {\n          resolve(evt.target.result);\n        } else {\n          reject(\n            \"Blob had an unexpected format: blob.target.result is undefined\\n\" +\n              evt\n          );\n        }\n      };\n      reader.onerror = function (err) {\n        reject(err);\n      };\n      reader.readAsText(blob);\n    });\n  }\n\n// Fetch the access token from local storage, or else check if\n// it is in the URL as a result of OAuth\nfunction getAccessToken() {\n  const cached_token = localStorage.getItem(ACCESS_TOKEN_COOKIE)\n  if (cached_token !== null) {\n    return cached_token;\n  }\n\n  const url_token = parseQueryString(window.location.hash).access_token\n  if (url_token) {\n    localStorage.setItem(ACCESS_TOKEN_COOKIE, url_token)\n  }\n  return url_token\n}\n\nexport function isAuthenticated() {\n  return !!getAccessToken();\n}\n\nconst dbx = isAuthenticated() \n    ? new Dropbox({ fetch, accessToken: getAccessToken() })\n    : new Dropbox({ fetch, clientId: DROPBOX_APP_KEY });\n\nasync function upload(state: State): Promise<void> {\n    try {\n        state.dirty = false;\n        const result = await dbx.filesUpload({\n            contents: JSON.stringify(state.snapshot),\n            path: CLOUD_PATH,\n            mode: { \".tag\": \"overwrite\" },\n            mute: true,\n        })\n        console.log(\"Upload successful\");\n        console.log(result);\n    }\n    catch (e) {\n        console.error(\"Upload failed!\");\n        console.error(e);\n        state.dirty = true;\n    }\n}\n\nasync function download(): Promise<Snapshot | null> {\n    try {\n        const result   = await dbx.filesDownload({ path: CLOUD_PATH }) as any;\n        const response = await readBlob(result.fileBlob) as string\n        const snapshot = JSON.parse(response) as Snapshot;\n        return snapshot;\n    } catch (err) {\n        console.error(\"Error fetching data from cloud:\");\n        console.error(err);\n        return null;\n    }\n}\n\nexport type AuthenticatedCloud = {\n    isAuthenticated: true,\n    upload: (state: State) => Promise<void>,\n    download: () => Promise<Snapshot | null>\n}\n\nexport type UnauthenticatedCloud = {\n    isAuthenticated: false,\n    authenticationURL: string\n}\n\nexport type Cloud = AuthenticatedCloud | UnauthenticatedCloud\n\nconst Cloud: Cloud = isAuthenticated() ? \n    {\n        isAuthenticated: true,\n        upload, download\n    }\n    :\n    {\n        isAuthenticated: false,\n        authenticationURL: dbx.getAuthenticationUrl(window.location.toString())\n    }\n\nexport default Cloud\n\n\n","import React, { useRef, useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactMarkdown from 'react-markdown';\nimport RemarkMathPlugin from 'remark-math';\nimport RemarkHighlightPlugin from 'remark-highlight.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport Hotkeys from 'react-hot-keys';\nimport './index.scss';\nimport * as serviceWorker from './serviceWorker';\nimport { State, interpretKeypress, Card, Keypress, ID, Index, Note, Snapshot, DB_STRING, Mode } from './model';\nimport 'materialize-css/dist/js/materialize.min.js';\nimport 'katex/dist/katex.min.css';\nimport NoteEditor from './NoteEditor';\nimport Dropbox, { AuthenticatedCloud } from './cloud';\nimport logo from './logo.jpeg';\nimport * as smoothscroll from 'seamless-scroll-polyfill';\nsmoothscroll.polyfill();\n\n\ntype CardProps = { card: Card, id: ID, state: State, isFocused: boolean, isSelected: boolean, mode: Mode }\ntype PreviewProps = { card: Card, id: ID, state: State }\n\nfunction onKeyDown(e: React.KeyboardEvent) {\n  if (state) {\n    if (e.key === 'Escape') {\n      state.mode = 'viewing'\n      state.save()\n      render()\n    }\n  }\n}\n\nfunction scrollToElement(el : HTMLElement) {\n  el.scrollIntoView({behavior: \"smooth\", block: \"center\"})\n}\n\nconst EditNote = React.memo((\n  props: { note: Note, id: ID }\n): JSX.Element => {\n\n  const {note, id} = props\n  const ref: React.MutableRefObject<HTMLTextAreaElement | null> = useRef(null)\n\n  if (ref.current)\n    scrollToElement(ref.current)\n\n  return (\n    <div className=\"card-panel z-depth-3 edited-note\">\n      <NoteEditor note={note} id={id} updateNote={updateNote} onKeyDown={onKeyDown} />\n    </div>\n  )\n})\n\nconst MarkdownRenderers: ReactMarkdown.Renderers = {\n  math: ({value}) => <BlockMath>{value}</BlockMath>,\n  inlineMath: ({ value }) => <InlineMath>{value}</InlineMath>,\n  code: ({language, value}) => <SyntaxHighlighter language={language} style={docco}>{value}</SyntaxHighlighter>\n}\n\nconst ViewNote = React.memo((\n  props: { card: Note, id: ID, state: State, isFocused: boolean, isSelected: boolean }\n): JSX.Element => {\n\n  const ifFocused = props.isFocused ? \"z-depth-3\" : \"\";\n  const ifSelected = props.isSelected ? \"blue lighten-5\" : \"\";\n  const className = [\"card-panel\", ifFocused, ifSelected].join(\" \");\n\n  const ref: React.MutableRefObject<HTMLDivElement | null> = useRef(null)\n\n  useEffect( () => {\n    const el = ref.current\n    if (el && props.isFocused) {\n      console.log(\"Scrolling to\", props.id);\n\n      setTimeout(() => {\n        scrollToElement(el)\n      }, 20)\n    }\n  })\n\n  return (\n    <div className={className} ref={ref}>\n      <ReactMarkdown \n        source={props.card.contents}\n        plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n        renderers={MarkdownRenderers as any}\n      />\n    </div>\n  )\n})\n\nconst RenderCard = React.memo((props: CardProps): JSX.Element => {\n  const {card, id, state, isFocused} = props;\n\n  if (card.type === 'index') {\n    return (\n      <div>\n        {`Index: (${card.contents.length} cards)`}\n      </div>\n    )\n  }\n  else {\n\n    if (isFocused && state.mode === 'editing') {\n      return (\n        <EditNote note={card} id={id} />\n      )\n    }\n    else {\n      return (\n        <ViewNote {...props} card={card} />\n      )\n    }\n  }\n})\n\nconst CardPreview = React.memo(({card, id, state}: PreviewProps): JSX.Element => {\n  if (card.type === 'index') {\n    return (\n      <div className=\"card-panel truncate\">\n        {`Index: (${card.contents.length} cards)`}\n      </div>\n    )\n  }\n  else {\n    const words = card.contents.split(\" \");\n    const preview = words.length > 20 \n      ? words.slice(0,20).join(\" \") + \"...\" \n      : card.contents;\n\n    return (\n      <div className=\"card-panel\">\n        <ReactMarkdown \n          source={preview}\n          plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n          renderers={MarkdownRenderers as any}\n        />\n      </div>\n    )\n  }\n})\n\nfunction Search({state}: {state: State | null}): JSX.Element {\n  const [query, setQuery] = useState(\"\");\n  const ref: React.MutableRefObject<HTMLInputElement | null> = useRef(null)\n\n  function onSubmit(event: React.SyntheticEvent) {\n    event.preventDefault()\n    if (state) {\n      state.search(query)\n      render()\n      if (ref.current) ref.current.blur()\n    }\n  }\n  function onKeyDown(e: React.KeyboardEvent) {\n    if (e.key === 'Escape') {\n      if (ref.current) ref.current.blur()\n    }\n  }\n\n  return (\n    <form className=\"input-field\" onSubmit={onSubmit}>\n      <i className=\"material-icons prefix\">search</i>\n      <input id=\"icon_prefix\" type=\"text\" ref={ref}\n        onChange={ e => setQuery(e.target.value) } \n        onKeyDown={onKeyDown} />\n      <label htmlFor=\"icon_prefix\">Search</label>\n    </form>\n  )\n}\n\nfunction Editor({state}: {state: State | null}): JSX.Element {\n\n  if (state === null) {\n    return (\n      <div className=\"row\">\n        <div className=\"col s3 offset-s4\">\n          <div className=\"card-panel valign-wrapper\">\n            <b className=\"center-align\">Loading...</b>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  const cards = state.currentIndex.contents\n  const focusedID = cards[state.focus]\n  const outgoing = state.db[focusedID + \"-outgoing\"] as Index | undefined\n  const incoming = state.db[focusedID + \"-incoming\"] as Index | undefined\n\n  return (\n    <div className=\"row\">\n      <div id=\"left-panel\" className=\"pinned col l3 offset-l1 m3 hide-on-small-only\">\n        <a href=\"/\"><img id=\"logo\" src={logo} alt=\"Go home\" /></a>\n        {incoming && incoming.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} id={id} state={state} />\n        })}\n      </div>\n      <div id=\"main-panel\" className=\"col l4 offset-l4 m6 offset-m3 s10 offset-s1\"> \n        <Search state={state} />\n        {\n          Dropbox.isAuthenticated ||\n          <div className=\"card-panel\">\n            <a href={Dropbox.authenticationURL}>Sign in to Dropbox</a>\n          </div>  \n        }\n        {cards.map(function (id: ID, i: number) {\n            const card = state.db[id]\n            const isFocused = state.focus === i\n            const isSelected = state.mode === 'selecting' &&\n              ((state.focus <= i && i <= state.selection!) ||\n              (state.focus >= i && i >= state.selection!))\n\n\n            return <RenderCard id={id} card={card} key={i} state={state} isFocused={isFocused} isSelected={isSelected} mode={state.mode} />\n        })}\n      </div>\n      <div id=\"right-panel\" className=\"pinned col l3 offset-l8 m3 offset-m9 hide-on-small-only\">\n        {outgoing && outgoing.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} id={id} state={state} />\n        })}\n      </div>\n    </div>\n  )\n}\n\nconst keymap : { [key: string] : Keypress} = {\n  'Enter': 'enter',\n  'command+c': 'copy',\n  'command+x': 'cut',\n  'command+v': 'paste',\n  'command+z': 'undo',\n  'command+shift+z': 'redo',\n  'Space': 'space',\n  'right': 'right',\n  'left': 'left',\n  'up': 'up',\n  'down': 'down',\n  'Escape': 'back',\n  'Backspace': 'backspace',\n  'shift+down': 'shift+down',\n  'shift+up': 'shift+up',\n  'shift+f': 'find',\n  // VIM keybindings\n  'j': 'down',\n  'k': 'up',\n  'h': 'left',\n  'l': 'right',\n  'shift+h': 'back',\n  'shift+l': 'forward',\n  'u': 'undo',\n  'ctrl+r': 'redo',\n  'y': 'copy',\n  'p': 'paste',\n  'x': 'cut',\n  'd': 'backspace',\n  'i': 'enter',\n  'a': 'space'\n}\n\nconst boundKeys = Object.keys(keymap).join(\",\")\n\nfunction App() {\n  return (\n    <Hotkeys\n      keyName={boundKeys}\n      onKeyDown={handleKey}\n    >\n      <Editor state={state}/>\n    </Hotkeys>\n  );\n}\n\n\n\nlet state : State | null = null;\n\n// Periodically upload state to Dropbox\n\nif (Dropbox.isAuthenticated) {\n  setInterval(() => {\n    if (state !== null && state.dirty)\n      (Dropbox as AuthenticatedCloud).upload(state)\n  }, 10000)\n}\n\n\n// Initialize state, checking Dropbox and localStorage\n\n(async function () {\n  const cloudSnapshot = Dropbox.isAuthenticated ? await Dropbox.download() : null\n  cloudSnapshot && console.log(\"Got cloud snapshot:\", cloudSnapshot)\n\n  const text = localStorage.getItem(DB_STRING)\n  const localSnapshot = text ? JSON.parse(text) as Snapshot : null\n  console.log(\"Got snapshot from localstorage:\", localSnapshot)\n\n  // No previous work found... Start in the initial state.\n  if (localSnapshot === null && cloudSnapshot === null) {\n    state = new State(null);\n  }\n  // Cloud backup found, with no local save. Must be logging in on a new browser or cleared the cache.\n  else if (localSnapshot === null && cloudSnapshot !== null) {\n    state = new State(cloudSnapshot);\n  }\n  // If a local copy is found with no cloud backup, then load that local state.\n  else if (localSnapshot !== null && cloudSnapshot === null) {\n    state = new State(localSnapshot);\n  }\n  // At this point we know that both a local snapshot and a cloud snapshot exist.\n  // Load whichever one has the more recent time stamp.\n  else {\n    state = (localSnapshot!.timestamp < cloudSnapshot!.timestamp) \n      ? new State(cloudSnapshot) \n      : new State(localSnapshot);\n  }\n\n  render();\n\n})()\n\n\nfunction handleKey(key: string, event: any) {\n  if (state) {\n    // Prevent the default refresh event under WINDOWS system\n    event.preventDefault() \n    console.log(keymap[key]) \n    interpretKeypress(keymap[key], state);\n    console.log(state)\n    render()\n  }\n}; \n\nfunction updateNote(id : ID, contents : string) {\n  if (state) {\n    if (state.updateNote(id, contents)) {\n      render()\n    }\n    else {\n      console.error(`Cannot update card ${id}: not a note`)\n    }\n  }\n}\n\nfunction render() {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n  );  \n}\n\nwindow.onpopstate = function (e: PopStateEvent) {\n  console.log(\"Entered index \" + window.location.hash + \" focus \" + e.state.focus)\n  if (state) {\n    state.view(window.location.hash.slice(1), e.state.focus)\n    render()\n  }\n}\n\nrender()\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();"],"sourceRoot":""}