{"version":3,"sources":["logo.jpeg","serviceWorker.ts","search.ts","model.ts","NoteEditor.tsx","cloud.ts","index.tsx"],"names":["module","exports","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","removeFormatting","text","a","Promise","resolve","reject","remark","use","RemarkMathPlugin","strip","process","err","file","String","getFeatures","expandedText","contractions","expand","tokens","natural","PorterStemmer","tokenizeAndStem","vec","token","undefined","Object","keys","length","addVecToIndex","id","index","entries","count","addToIndex","contents","features","rankedCosineSimilarity","vec1","vec2","intersectCount","includes","numerator","cosineSimilarity","State","snapshot","db","root","currentIndexID","focus","mode","clipboard","selection","dirty","this","uuid","type","hash","slice","history","notes","Search","localStorage","setItem","JSON","stringify","prototype","hasOwnProperty","call","card","replaceState","pushState","view","back","forward","currentIndex","query","results","queryString","documents","Map","occurrences","weight","get","set","similarity","push","sort","b","map","newIndex","enter","save","note","splice","indexID","endsWith","substr","incomingIndex","findIndex","x","outgoingIndex","remove","lower","Math","min","upper","max","i","focusedCardID","insertAfter","timestamp","Date","now","serialize","value","n","Node","string","join","deserialize","split","line","children","NoteEditor","props","useState","setValue","editor","useMemo","withHistory","withReact","createEditor","onChange","updateNote","autoFocus","onKeyDown","placeholder","style","marginTop","marginBottom","readBlob","blob","reader","FileReader","onload","evt","target","result","onerror","readAsText","getAccessToken","cached_token","getItem","url_token","str","ret","create","trim","replace","forEach","param","parts","key","shift","val","decodeURIComponent","val2","Array","isArray","parseQueryString","access_token","isAuthenticated","dbx","Dropbox","fetch","accessToken","clientId","filesUpload","path","mute","filesDownload","fileBlob","response","parse","Cloud","upload","download","authenticationURL","getAuthenticationUrl","toString","e","render","scrollToElement","el","scrollIntoView","behavior","block","EditNote","ref","useRef","current","className","MarkdownRenderers","math","inlineMath","code","language","docco","ViewNote","isFocused","isSelected","useEffect","setTimeout","source","plugins","RemarkHighlightPlugin","renderers","RenderCard","CardPreview","words","preview","setQuery","onSubmit","event","preventDefault","search","blur","htmlFor","Editor","cards","focusedID","outgoing","incoming","href","src","logo","alt","keymap","boundKeys","App","keyName","handleKey","goBack","goForward","newNote","paste","removeSelection","copy","goUp","goDown","interpretKeypress","ReactDOM","StrictMode","document","getElementById","setInterval","cloudSnapshot","localSnapshot","onpopstate","URL","origin","addEventListener","headers","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"+EAAAA,EAAOC,QAAU,IAA0B,mC,qPCYrCC,G,OAAcC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,4DA8CN,SAASC,EAAgBC,EAAeC,GACtCC,UAAUC,cACPC,SAASJ,GACTK,MAAK,SAAAC,GACJA,EAAaC,cAAgB,WAC3B,IAAMC,EAAmBF,EAAaG,WACd,MAApBD,IAGJA,EAAiBE,cAAgB,WACA,cAA3BF,EAAiBG,QACfT,UAAUC,cAAcS,YAI1BC,QAAQC,IACN,iHAKEb,GAAUA,EAAOc,UACnBd,EAAOc,SAAST,KAMlBO,QAAQC,IAAI,sCAGRb,GAAUA,EAAOe,WACnBf,EAAOe,UAAUV,WAO5BW,OAAM,SAAAC,GACLL,QAAQK,MAAM,4CAA6CA,M,6GC3E1D,SAAeC,EAAtB,kC,4CAAO,WAAgCC,GAAhC,SAAAC,EAAA,+EACE,IAAIC,SAAQ,SAACC,EAASC,GAC3BC,MACGC,IAAIC,KACJD,IAAIE,KACJC,QAAQT,GAAM,SAAUU,EAAKC,GACxBD,EAAKN,EAAOM,GACXP,EAAQS,OAAOD,WAPrB,4C,sBAgBA,SAASE,EAAYb,GAC1B,IADoD,EAC9Cc,EAAeC,IAAaC,OAAOhB,GACnCiB,EAASC,IAAQC,cAAcC,gBAAgBN,GAC/CO,EAAkB,GAH4B,cAIhCJ,GAJgC,IAIpD,2BAA4B,CAAC,IAAlBK,EAAiB,QACxBD,EAAIC,QAAwBC,IAAfF,EAAIC,GAAuB,EAAID,EAAIC,GAAS,GALT,8BAQpD,cAAoBE,OAAOC,KAAKJ,GAAhC,eAAsC,CAAjC,IAAMC,EAAK,KACZD,EAAIC,GAASD,EAAIC,GAASL,EAAOS,OAErC,OAAOL,EAGT,SAASM,EAAcC,EAAQP,EAAiBQ,GAC5C,cAA6BL,OAAOM,QAAQT,GAA5C,eAAkD,CAAC,IAAD,sBAAtCC,EAAsC,KAA/BS,EAA+B,UACzBR,IAAjBM,EAAMP,KACNO,EAAMP,GAAS,IAEnBO,EAAMP,GAAOM,GAAMG,GAapB,SAAeC,EAAtB,sC,4CAAO,WAA0BJ,EAAQK,EAAkBJ,GAApD,iBAAA5B,EAAA,sEACgBF,EAAiBkC,GADjC,OACGjC,EADH,OAEGkC,EAAWrB,EAAYb,GAC7B2B,EAAcC,EAAIM,EAAUL,GAHzB,4C,sBA+BP,SAASM,EAAuBC,EAAkBC,GAE9C,IADA,IAAIC,EAAiB,EACrB,MAAoBd,OAAOC,KAAKW,GAAhC,eAAuC,CAAlC,IAAMd,EAAK,KACRE,OAAOC,KAAKY,GAAME,SAASjB,KAC3BgB,GAAkB,GAI1B,OAAOA,EAvBX,SAA0BF,EAAkBC,GAGxC,IAFA,IAAIG,EAAY,EAEhB,MAAoBhB,OAAOC,KAAKW,GAAhC,eAAuC,CAAlC,IAAMd,EAAK,KACZkB,IAAcJ,EAAKd,IAAU,IAAMe,EAAKf,IAAU,GAGtD,OAAOkB,EAgBiBC,CAAiBL,EAAMC,GClB5C,IAQMK,EAAb,WAcI,WAAYC,GAA4B,yBAZxCC,QAYuC,OAXvCC,UAWuC,OARvCC,oBAQuC,OAPvCC,WAOuC,OANvCC,UAMuC,OALvCC,eAKuC,OAJvCC,eAIuC,OAHvCC,WAGuC,OAFvCtB,WAEuC,EAClB,OAAbc,GACAS,KAAKP,KAAOQ,cACZD,KAAKR,GAAK,GACVQ,KAAKR,GAAGQ,KAAKP,MAAQ,CAAES,KAAM,QAASrB,SAAU,MAGhDmB,KAAKP,KAAOF,EAASE,KACrBO,KAAKR,GAAKD,EAASC,IAEM,KAAzBrE,OAAOC,SAAS+E,MAChBH,KAAKN,eAAiBvE,OAAOC,SAAS+E,KAAKC,MAAM,GACjDJ,KAAKL,MAAQxE,OAAOkF,QAAQlE,MAAMwD,QAAU,IAG5CK,KAAKN,eAAiBM,KAAKP,KAC3BO,KAAKL,OAAS,GAElBK,KAAKJ,KAAO,UACZI,KAAKH,UAAY,GACjBG,KAAKD,OAAQ,EAGbC,KAAKvB,MDzHF,GCkGgC,oBAwBVuB,KAAKM,SAxBK,IAwBnC,2BAAuC,CAAC,IAAD,yBACnCC,EADmC,UACR1B,SAAUmB,KAAKvB,QAzBX,+BAd3C,mDAoDQ+B,aAAaC,QA5DI,WA4DeC,KAAKC,UAAUX,KAAKT,WACpDlD,QAAQC,IAAI,iCACZ0D,KAAKD,OAAQ,IAtDrB,iIAqEyBC,KAAKR,IArE9B,iDAqEmBhB,EArEnB,YAsEgBJ,OAAOwC,UAAUC,eAAeC,KAAKd,KAAKR,GAAIhB,GAtE9D,mBAwEkC,UADZuC,EAAOf,KAAKR,GAAGhB,IACZ0B,KAxEzB,gBAyEoB,OAzEpB,SAyE0B,CAAC1B,EAAIuC,GAzE/B,kGAiFSvC,EAAQmB,GACTK,KAAKN,eAAiBlB,EACtBwB,KAAKL,WAAkBxB,IAAVwB,GAAuB,EAAIA,IAnFhD,4BAqFUnB,GACF,IAAMmB,EAAQK,KAAKR,GAAGhB,GAAIK,SAASP,OAAS,EAAI,GAAK,EACrDnD,OAAOkF,QAAQW,aAAa,CAAErB,MAAOK,KAAKL,OAAS,GAAI,IAAMK,KAAKN,gBAClEvE,OAAOkF,QAAQY,UAAU,CAACtB,MAAOA,GAAQ,GAAI,IAAMnB,GACnDwB,KAAKkB,KAAK1C,EAAImB,KAzFtB,+BA4FQxE,OAAOkF,QAAQc,SA5FvB,kCA+FQhG,OAAOkF,QAAQe,YA/FvB,6BAqG0B,YAAdpB,KAAKJ,MACDI,KAAKL,OAAS,IACdK,KAAKL,MAAQK,KAAKL,MAAQ,GAGhB,cAAdK,KAAKJ,MACDI,KAAKL,MAAQ,IACbK,KAAKL,MAAQK,KAAKL,MAAQ,KA5G1C,+BAiHYK,KAAKL,MAAQK,KAAKqB,aAAaxC,SAASP,OAAS,IACjD0B,KAAKL,MAAQK,KAAKL,MAAQ,KAlHtC,6BAwHW2B,GACH,IAAMC,ED5GP,SAAgBC,EAAqB/C,GACxC,IAAM6C,EAAQ7D,EAAY+D,GAC1B,GAAkC,IAA9BpD,OAAOC,KAAKiD,GAAOhD,OAAc,MAAO,GAS5C,IADA,IAAMmD,EAAiC,IAAIC,IAC3C,MAAoBtD,OAAOC,KAAKiD,GAAhC,eAEI,IAFC,IAAMpD,EAAK,KACNyD,EAAclD,EAAMP,IAAU,GACpC,MAA2BE,OAAOM,QAAQiD,GAA1C,eAAwD,CAAC,IAAD,sBAA5CnD,EAA4C,KAAxCoD,EAAwC,KAC9C3D,EAAMwD,EAAUI,IAAIrD,IAAO,GACjCP,EAAIC,GAAS0D,EACbH,EAAUK,IAAItD,EAAIP,GAM1B,IAtB4D,EAsBtD8D,EAA6B,GAtByB,cAuBpCN,EAAU/C,WAvB0B,IAuB5D,2BAA6C,CAAC,IAAD,yBAAjCF,EAAiC,KAA7BP,EAA6B,KACzC8D,EAAWC,KAAK,CAACxD,EAAIO,EAAuBuC,EAAOrD,MAxBK,8BA8B5D,OAHA8D,EAAWE,MAAK,SAACpF,EAAEqF,GAAH,OAASA,EAAE,GAAKrF,EAAE,MAG3BkF,EAAWI,KAAI,mCAAE3D,EAAF,iBAAaA,KAAI4B,MAAM,EAAE,IC8E3BG,CAAce,EAAOtB,KAAKvB,OACpCD,EAAKwB,KAAKoC,WACFpC,KAAKR,GAAGhB,GAChBK,SAAW0C,EACjBvB,KAAKqC,MAAM7D,GACXwB,KAAKsC,SA9Hb,iCAgIe9D,EAASK,GAChB,IAAM0D,EAAOvC,KAAKR,GAAGhB,GACrB,SAAI+D,GAAsB,SAAdA,EAAKrC,QACbqC,EAAK1D,SAAWA,GACT,KApInB,kCA0IgBc,EAAenB,GACvBwB,KAAKqB,aAAaxC,SAAS2D,OAAO7C,EAAQ,EAAG,EAAGnB,GAIhD,IAAMiE,EAAUzC,KAAKN,eACrB,GAAI+C,EAAQC,SAAS,aAAc,CAC/B,IAAMH,EAAYE,EAAQE,OAAO,EAAGF,EAAQnE,OAAS,GAC/B0B,KAAKR,GAAGhB,EAAK,aACrBK,SAASmD,KAAKO,GAEhC,GAAIE,EAAQC,SAAS,aAAc,CAC/B,IAAMH,EAAYE,EAAQE,OAAO,EAAGF,EAAQnE,OAAS,GAC/B0B,KAAKR,GAAGhB,EAAK,aACrBK,SAASmD,KAAKO,GAEhCvC,KAAKsC,SA1Jb,6BA4JW3C,GACH,IAAMnB,EAAKwB,KAAKqB,aAAaxC,SAASc,GACtCK,KAAKqB,aAAaxC,SAAS2D,OAAO7C,EAAO,GAErCK,KAAKL,MAAQK,KAAKqB,aAAaxC,SAASP,OAAS,IACjD0B,KAAKL,MAAQK,KAAKL,MAAQ,GAM9B,IAAM8C,EAAUzC,KAAKN,eACrB,GAAI+C,EAAQC,SAAS,aAAc,CAC/B,IAAMH,EAAYE,EAAQE,OAAO,EAAGF,EAAQnE,OAAS,GAC/CsE,EAAgB5C,KAAKR,GAAGhB,EAAK,aAC7BmB,EAAQiD,EAAc/D,SAASgE,WAAU,SAAAC,GAAC,OAAIA,IAAMP,KAC1DK,EAAc/D,SAAS2D,OAAO7C,EAAO,GAEzC,GAAI8C,EAAQC,SAAS,aAAc,CAC/B,IAAMH,EAAYE,EAAQE,OAAO,EAAGF,EAAQnE,OAAS,GAC/CyE,EAAgB/C,KAAKR,GAAGhB,EAAK,aAC7BmB,EAAQoD,EAAclE,SAASgE,WAAU,SAAAC,GAAC,OAAIA,IAAMP,KAC1DQ,EAAclE,SAAS2D,OAAO7C,EAAO,GAEzCK,KAAKsC,SApLb,gCAuLQ,IAAM9D,EAAKyB,cAKX,OAJAD,KAAKR,GAAGhB,GAAM,CAAC0B,KAAM,OAAQrB,SAAU,IACvCmB,KAAKR,GAAGhB,EAAK,aAAe,CAAC0B,KAAM,QAASrB,SAAU,IACtDmB,KAAKR,GAAGhB,EAAK,aAAe,CAAC0B,KAAM,QAASrB,SAAU,IACtDmB,KAAKsC,OACE9D,IA5Lf,iCA+LQ,IAAMA,EAAKyB,cAGX,OAFAD,KAAKR,GAAGhB,GAAM,CAAC0B,KAAM,QAASrB,SAAU,IACxCmB,KAAKsC,OACE9D,IAlMf,wCAqMQ,GAAkB,YAAdwB,KAAKJ,KACLI,KAAKgD,OAAOhD,KAAKL,YAEhB,GAAkB,cAAdK,KAAKJ,KAAsB,CAGhC,IAFA,IAAMqD,EAAQC,KAAKC,IAAInD,KAAKL,MAAOK,KAAKF,WAClCsD,EAAQF,KAAKG,IAAIrD,KAAKL,MAAOK,KAAKF,WAC/BwD,EAAIL,EAAOK,GAAKF,EAAOE,IAG5BtD,KAAKgD,OAAOC,GAEhBjD,KAAKJ,KAAO,UACZI,KAAKF,eAAY3B,EACjB6B,KAAKL,MAAQsD,EAGbjD,KAAKL,MAAQK,KAAKqB,aAAaxC,SAASP,OAAS,IACjD0B,KAAKL,MAAQK,KAAKL,MAAQ,KAtNtC,6BA0NQ,GAAkB,YAAdK,KAAKJ,KACLI,KAAKH,UAAY,CAACG,KAAKuD,oBAEtB,GAAkB,cAAdvD,KAAKJ,KAAsB,CAChC,IAAMnB,EAAQuB,KAAKqB,aACb4B,EAAQC,KAAKC,IAAInD,KAAKL,MAAOK,KAAKF,WAClCsD,EAAQF,KAAKG,IAAIrD,KAAKL,MAAOK,KAAKF,WACxCE,KAAKH,UAAY,GACjB,IAAK,IAAIyD,EAAIL,EAAOK,GAAKF,EAAOE,IAC5BtD,KAAKH,UAAUmC,KAAKvD,EAAMI,SAASyE,OAnOnD,8BAwOQ,IAAK,IAAIA,EAAI,EAAGA,EAAItD,KAAKH,UAAUvB,OAAQgF,IACvCtD,KAAKwD,YAAYxD,KAAKL,MAAQ2D,EAAGtD,KAAKH,UAAUyD,MAzO5D,+BA4CQ,MAAO,CACH9D,GAAIQ,KAAKR,GACTC,KAAMO,KAAKP,KACXgE,UAAWC,KAAKC,SA/C5B,mCA0DQ,OAAO3D,KAAKR,GAAGQ,KAAKN,kBA1D5B,oCA8DQ,OAAOM,KAAKqB,aAAaxC,SAASmB,KAAKL,SA9D/C,kCAkEQ,OAAOK,KAAKuD,cAAgBvD,KAAKR,GAAGQ,KAAKuD,oBAAiBpF,MAlElE,K,wCCzEMyF,EAAY,SAACC,GACjB,OACEA,EAEG1B,KAAI,SAAA2B,GAAC,OAAIC,IAAKC,OAAOF,MAErBG,KAAK,OAKNC,EAAc,SAACF,GAEnB,OAAOA,EAAOG,MAAM,MAAMhC,KAAI,SAACiC,GAC7B,MAAO,CACLC,SAAU,CAAC,CAAEzH,KAAMwH,SAKVE,EAzCI,SAACC,GAAkB,IAAD,EACTC,mBAAiBN,EAAYK,EAAMhC,KAAK1D,WAD/B,mBAC5BgF,EAD4B,KACrBY,EADqB,KAE7BC,EAASC,mBAAQ,kBAAMC,YAAYC,YAAUC,kBAAkB,IAOrE,OACE,kBAAC,IAAD,CAAOJ,OAAQA,EAAQb,MAAOA,EAAOkB,SANvC,SAAkBlB,GAChBY,EAASZ,GACTU,EAAMS,WAAWT,EAAM/F,GAAIoF,EAAUC,MAKnC,kBAAC,IAAD,CAAUoB,WAAS,EACjBC,UAAWX,EAAMW,UACjBC,YAAY,qBACZC,MAAO,CAACC,UAAW,OAAQC,aAAc,Y,yBC0BjD,SAASC,EAASC,GACd,OAAO,IAAI1I,SAAQ,SAACC,EAASC,GAC3B,IAAMyI,EAAS,IAAIC,WACnBD,EAAOE,OAAS,SAAUC,GACpBA,GAAOA,EAAIC,QAAUD,EAAIC,OAAOC,OAClC/I,EAAQ6I,EAAIC,OAAOC,QAEnB9I,EACE,mEACE4I,IAIRH,EAAOM,QAAU,SAAUzI,GACzBN,EAAOM,IAETmI,EAAOO,WAAWR,MAMxB,SAASS,IACP,IAAMC,EAAe1F,aAAa2F,QAhER,wBAiE1B,GAAqB,OAAjBD,EACF,OAAOA,EAGT,IAAME,EAlER,SAA0BC,GACxB,IAAIC,EAAMlI,OAAOmI,OAAO,MAExB,MAAmB,kBAARF,EACFC,GAGTD,EAAMA,EAAIG,OAAOC,QAAQ,YAAa,MAMtCJ,EAAIlC,MAAM,KAAKuC,SAAQ,SAAUC,GAC/B,IAAIC,EAAQD,EAAMF,QAAQ,MAAO,KAAKtC,MAAM,KAGxC0C,EAAMD,EAAME,QACZC,EAAMH,EAAMtI,OAAS,EAAIsI,EAAM3C,KAAK,UAAO9F,EAE/C0I,EAAMG,mBAAmBH,GAIzB,IAAII,OAAe9I,IAAR4I,EAAoB,KAAOC,mBAAmBD,QAExC5I,IAAbmI,EAAIO,GACNP,EAAIO,GAAOI,EACFC,MAAMC,QAAQb,EAAIO,IAC3BP,EAAIO,GAAK7E,KAAKiF,GAEdX,EAAIO,GAAO,CAACP,EAAIO,GAAMI,MAInBX,GAzBEA,EAwDSc,CAAiBjM,OAAOC,SAAS+E,MAAMkH,aAIzD,OAHIjB,GACF5F,aAAaC,QAvEW,uBAuEkB2F,GAErCA,EAGF,SAASkB,IACd,QAASrB,IAGX,IAAMsB,GAAMD,IACN,IAAIE,UAAQ,CAAEC,UAAOC,YAAazB,MAClC,IAAIuB,UAAQ,CAAEC,UAAOE,SApFH,oB,8CAsFxB,WAAsBxL,GAAtB,eAAAU,EAAA,sEAEQV,EAAM4D,OAAQ,EAFtB,SAG6BwH,GAAIK,YAAY,CACjC/I,SAAU6B,KAAKC,UAAUxE,EAAMoD,UAC/BsI,KA1FO,iBA2FPjI,KAAM,CAAE,OAAQ,aAChBkI,MAAM,IAPlB,OAGchC,EAHd,OASQzJ,QAAQC,IAAI,qBACZD,QAAQC,IAAIwJ,GAVpB,gDAaQzJ,QAAQK,MAAM,kBACdL,QAAQK,MAAR,MACAP,EAAM4D,OAAQ,EAftB,0D,oEAmBA,gCAAAlD,EAAA,+EAE+B0K,GAAIQ,cAAc,CAAEF,KA1GhC,mBAwGnB,cAEc/B,EAFd,gBAG+BP,EAASO,EAAOkC,UAH/C,cAGcC,EAHd,OAIc1I,EAAWmB,KAAKwH,MAAMD,GAJpC,kBAKe1I,GALf,yCAOQlD,QAAQK,MAAM,mCACdL,QAAQK,MAAR,MARR,kBASe,MATf,2D,sBA0BA,IAWeyL,GAXMb,IACjB,CACIA,iBAAiB,EACjBc,O,6CAAQC,S,6CAGZ,CACIf,iBAAiB,EACjBgB,kBAAmBf,GAAIgB,qBAAqBpN,OAAOC,SAASoN,a,qBC9HpE,SAAStD,GAAUuD,GACbtM,IACY,WAAVsM,EAAE5B,MACJ1K,GAAMyD,KAAO,UACbzD,GAAMmG,OACNoG,MAKN,SAASC,GAAgBC,GACvBA,EAAGC,eAAe,CAACC,SAAU,SAAUC,MAAO,WAGhD,SAASC,GACPzE,GACc,IAEPhC,EAAYgC,EAAZhC,KAAM/D,EAAM+F,EAAN/F,GACPyK,EAA0DC,iBAAO,MAKvE,OAHID,EAAIE,SACNR,GAAgBM,EAAIE,SAGpB,yBAAKC,UAAU,oCACb,kBAAC,EAAD,CAAY7G,KAAMA,EAAM/D,GAAIA,EAAIwG,WAAYA,GAAYE,UAAWA,MAKzE,IAAMmE,GAA6C,CACjDC,KAAM,gBAAEzF,EAAF,EAAEA,MAAF,OAAa,kBAAC,YAAD,KAAYA,IAC/B0F,WAAY,gBAAG1F,EAAH,EAAGA,MAAH,OAAe,kBAAC,aAAD,KAAaA,IACxC2F,KAAM,gBAAEC,EAAF,EAAEA,SAAU5F,EAAZ,EAAYA,MAAZ,OAAuB,kBAAC,IAAD,CAAmB4F,SAAUA,EAAUrE,MAAOsE,KAAQ7F,KAGrF,SAAS8F,GACPpF,GAGA,IAEM6E,EAAY,CAAC,aAFD7E,EAAMqF,UAAY,YAAc,GAC/BrF,EAAMsF,WAAa,iBAAmB,IACD5F,KAAK,KAEvDgF,EAAqDC,iBAAO,MAalE,OAXAY,qBAAW,WACT,IAAMlB,EAAKK,EAAIE,QACXP,GAAMrE,EAAMqF,YACdvN,QAAQC,IAAI,eAAgBiI,EAAM/F,IAElCuL,YAAW,WACTpB,GAAgBC,KACf,QAKL,yBAAKQ,UAAWA,EAAWH,IAAKA,GAC9B,kBAAC,IAAD,CACEe,OAAQzF,EAAMxD,KAAKlC,SACnBoL,QAAS,CAAC9M,IAAkB+M,KAC5BC,UAAWd,MAMnB,SAASe,GAAW7F,GAAgC,IAC3CxD,EAA8BwD,EAA9BxD,KAAMvC,EAAwB+F,EAAxB/F,GAAIrC,EAAoBoI,EAApBpI,MAAOyN,EAAarF,EAAbqF,UAExB,MAAkB,UAAd7I,EAAKb,KAEL,+CACca,EAAKlC,SAASP,OAD5B,YAOEsL,GAA4B,YAAfzN,EAAMyD,KAEnB,kBAACoJ,GAAD,CAAUzG,KAAMxB,EAAMvC,GAAIA,IAK1B,kBAACmL,GAAD,iBAAcpF,EAAd,CAAqBxD,KAAMA,KAMnC,SAASsJ,GAAT,GAAoE,IAA9CtJ,EAA6C,EAA7CA,KAA6C,EAAvCvC,GAAuC,EAAnCrC,MAC9B,GAAkB,UAAd4E,EAAKb,KACP,OACE,yBAAKkJ,UAAU,uBAAf,kBACcrI,EAAKlC,SAASP,OAD5B,YAMF,IAAMgM,EAAQvJ,EAAKlC,SAASsF,MAAM,KAC5BoG,EAAUD,EAAMhM,OAAS,GAC3BgM,EAAMlK,MAAM,EAAE,IAAI6D,KAAK,KAAO,MAC9BlD,EAAKlC,SAET,OACE,yBAAKuK,UAAU,cACb,kBAAC,IAAD,CACEY,OAAQO,EACRN,QAAS,CAAC9M,IAAkB+M,KAC5BC,UAAWd,MAOrB,SAAS9I,GAAT,GAA8D,IAA7CpE,EAA4C,EAA5CA,MAA4C,EACjCqI,mBAAS,IADwB,mBACpDlD,EADoD,KAC7CkJ,EAD6C,KAErDvB,EAAuDC,iBAAO,MAgBpE,OACE,0BAAME,UAAU,cAAcqB,SAfhC,SAAkBC,GAChBA,EAAMC,iBACFxO,IACFA,EAAMyO,OAAOtJ,GACboH,KACIO,EAAIE,SAASF,EAAIE,QAAQ0B,UAW7B,uBAAGzB,UAAU,yBAAb,UACA,2BAAO5K,GAAG,cAAc0B,KAAK,OAAO+I,IAAKA,EACvClE,SAAW,SAAA0D,GAAC,OAAI+B,EAAS/B,EAAE5C,OAAOhC,QAClCqB,UAXN,SAAmBuD,GACH,WAAVA,EAAE5B,KACAoC,EAAIE,SAASF,EAAIE,QAAQ0B,UAU7B,2BAAOC,QAAQ,eAAf,WAKN,SAASC,GAAT,GAA8D,IAA7C5O,EAA4C,EAA5CA,MAEf,GAAc,OAAVA,EACF,OACE,yBAAKiN,UAAU,OACb,yBAAKA,UAAU,oBACb,yBAAKA,UAAU,6BACb,uBAAGA,UAAU,gBAAb,iBAOV,IAAM4B,EAAQ7O,EAAMkF,aAAaxC,SAC3BoM,EAAYD,EAAM7O,EAAMwD,OACxBuL,EAAW/O,EAAMqD,GAAGyL,EAAY,aAChCE,EAAWhP,EAAMqD,GAAGyL,EAAY,aAEtC,OACE,yBAAK7B,UAAU,OACb,yBAAK5K,GAAG,aAAa4K,UAAU,iDAC7B,uBAAGgC,KAAK,KAAI,yBAAK5M,GAAG,OAAO6M,IAAKC,KAAMC,IAAI,aACzCJ,GAAYA,EAAStM,SAASsD,KAAI,SAAU3D,EAAQ8E,GACjD,OAAO,kBAAC+G,GAAD,CAAaxD,IAAKvD,EAAGvC,KAAM5E,EAAMqD,GAAGhB,GAAKA,GAAIA,EAAIrC,MAAOA,QAGrE,yBAAKqC,GAAG,aAAa4K,UAAU,+CAC7B,kBAAC7I,GAAD,CAAQpE,MAAOA,IAEbqL,GAAQF,iBACR,yBAAK8B,UAAU,cACb,uBAAGgC,KAAM5D,GAAQc,mBAAjB,uBAGH0C,EAAM7I,KAAI,SAAU3D,EAAQ8E,GACzB,IAAMvC,EAAO5E,EAAMqD,GAAGhB,GAChBoL,EAAYzN,EAAMwD,QAAU2D,EAC5BuG,EAA4B,cAAf1N,EAAMyD,OACrBzD,EAAMwD,OAAS2D,GAAKA,GAAKnH,EAAM2D,WAChC3D,EAAMwD,OAAS2D,GAAKA,GAAKnH,EAAM2D,WAGlC,OAAO,kBAACsK,GAAD,CAAY5L,GAAIA,EAAIuC,KAAMA,EAAM8F,IAAKvD,EAAGnH,MAAOA,EAAOyN,UAAWA,EAAWC,WAAYA,QAGrG,yBAAKrL,GAAG,cAAc4K,UAAU,2DAC7B8B,GAAYA,EAASrM,SAASsD,KAAI,SAAU3D,EAAQ8E,GACjD,OAAO,kBAAC+G,GAAD,CAAaxD,IAAKvD,EAAGvC,KAAM5E,EAAMqD,GAAGhB,GAAKA,GAAIA,EAAIrC,MAAOA,SAO3E,IAAMqP,GAAuC,CAC3C,MAAS,QACT,YAAa,OACb,YAAa,MACb,YAAa,QACb,YAAa,OACb,kBAAmB,OACnB,MAAS,QACT,MAAS,QACT,KAAQ,OACR,GAAM,KACN,KAAQ,OACR,OAAU,OACV,UAAa,YACb,aAAc,aACd,WAAY,WAEZ,EAAK,OACL,EAAK,KACL,EAAK,OACL,EAAK,QACL,UAAW,OACX,UAAW,UACX,EAAK,OACL,SAAU,OACV,EAAK,OACL,EAAK,QACL,EAAK,MACL,EAAK,YACL,EAAK,QACL,EAAK,SAGDC,GAAYrN,OAAOC,KAAKmN,IAAQvH,KAAK,KAE3C,SAASyH,KACP,OACE,kBAAC,IAAD,CACEC,QAASF,GACTvG,UAAW0G,IAEX,kBAACb,GAAD,CAAQ5O,MAAOA,MAOrB,IAAIA,GAAuB,KA+C3B,SAASyP,GAAU/E,EAAa6D,GAC1BvO,KAEFuO,EAAMC,iBACNtO,QAAQC,IAAIkP,GAAO3E,IH7ShB,SAA2BA,EAAe1K,GAC7C,GAAmB,YAAfA,EAAMyD,KACN,GAAY,UAARiH,GAAmB1K,EAAMwD,OAAS,EAClCxD,EAAMyD,KAAO,eAEZ,GAAY,SAARiH,EACL1K,EAAM0P,cAEL,GAAY,YAARhF,EACL1K,EAAM2P,iBAEL,GAAY,UAARjF,EAAiB,CACtB,IAAMtE,EAAOpG,EAAM4P,UACnB5P,EAAMqH,YAAYrH,EAAMwD,MAAO4C,GAC/BpG,EAAMwD,MAAQxD,EAAMwD,MAAQ,EAC5BxD,EAAMyD,KAAO,eAEZ,GAAY,UAARiH,EACL1K,EAAM6P,aAEL,GAAY,UAARnF,GAAmB1K,EAAMwD,OAAS,EAAG,CAC1C,IAAM4C,EAAOpG,EAAMkF,aAAaxC,SAAS1C,EAAMwD,OAC/CxD,EAAMkG,MAAME,EAAO,kBAElB,GAAY,SAARsE,GAAkB1K,EAAMwD,OAAS,EAAG,CACzC,IAAM4C,EAAOpG,EAAMkF,aAAaxC,SAAS1C,EAAMwD,OAC/CxD,EAAMkG,MAAME,EAAO,aAGR,YAAfpG,EAAMyD,MAAqC,cAAfzD,EAAMyD,OACtB,cAARiH,GAAuB1K,EAAMwD,OAAS,EACtCxD,EAAM8P,kBAEO,SAARpF,GAAkB1K,EAAMwD,OAAS,GACtCxD,EAAM+P,OACN/P,EAAMyD,KAAO,UACbzD,EAAM2D,eAAY3B,GAEL,QAAR0I,GAAiB1K,EAAMwD,OAAS,GACrCxD,EAAM+P,OACN/P,EAAM8P,mBAEO,WAARpF,GACL1K,EAAMyD,KAAO,UACbzD,EAAM2D,eAAY3B,GAEL,OAAR0I,EACL1K,EAAMgQ,OAEO,SAARtF,EACL1K,EAAMiQ,SAEO,eAARvF,GAAwB1K,EAAMwD,OAAS,GAC5CxD,EAAMyD,KAAO,iBACWzB,IAApBhC,EAAM2D,YACN3D,EAAM2D,UAAY3D,EAAMwD,OAE5BxD,EAAMiQ,UAEO,aAARvF,IACL1K,EAAMyD,KAAO,iBACWzB,IAApBhC,EAAM2D,YACN3D,EAAM2D,UAAY3D,EAAMwD,OAE5BxD,EAAMgQ,SAGK,YAAfhQ,EAAMyD,MACM,WAARiH,IACA1K,EAAMyD,KAAO,WGyOrByM,CAAkBb,GAAO3E,GAAM1K,IAC/BE,QAAQC,IAAIH,IACZuM,MAIJ,SAAS1D,GAAWxG,EAASK,GACvB1C,KACEA,GAAM6I,WAAWxG,EAAIK,GACvB6J,KAGArM,QAAQK,MAAR,6BAAoC8B,EAApC,kBAKN,SAASkK,KACP4D,IAAS5D,OACP,kBAAC,IAAM6D,WAAP,KACE,kBAACb,GAAD,OAEFc,SAASC,eAAe,SAtExBjF,GAAQF,iBACVoF,aAAY,WACI,OAAVvQ,IAAkBA,GAAM4D,OACzByH,GAA+BY,OAAOjM,MACxC,KAML,sBAAC,gCAAAU,EAAA,0DACuB2K,GAAQF,gBAD/B,gCACuDE,GAAQa,WAD/D,8CAC4E,KAD5E,QACOsE,EADP,OAEkBtQ,QAAQC,IAAI,sBAAuBqQ,GAE9C/P,EAAO4D,aAAa2F,QHlMH,YGmMjByG,EAAgBhQ,EAAO8D,KAAKwH,MAAMtL,GAAoB,KAC5DP,QAAQC,IAAI,kCAAmCsQ,GAI7CzQ,GADoB,OAAlByQ,GAA4C,OAAlBD,EACpB,IAAIrN,EAAM,MAGO,OAAlBsN,GAA4C,OAAlBD,EACzB,IAAIrN,EAAMqN,GAGO,OAAlBC,GAA4C,OAAlBD,EACzB,IAAIrN,EAAMsN,GAKTA,EAAenJ,UAAYkJ,EAAelJ,UAC/C,IAAInE,EAAMqN,GACV,IAAIrN,EAAMsN,GAGhBlE,KA5BD,2CAAD,GAgEAvN,OAAO0R,WAAa,SAAUpE,GAC5BpM,QAAQC,IAAI,iBAAmBnB,OAAOC,SAAS+E,KAAO,UAAYsI,EAAEtM,MAAMwD,OACtExD,KACFA,GAAM+E,KAAK/F,OAAOC,SAAS+E,KAAKC,MAAM,GAAIqI,EAAEtM,MAAMwD,OAClD+I,OAIJA,KL7UO,SAAkBjN,GACvB,GAA6C,kBAAmBC,UAAW,CAMzE,GAJkB,IAAIoR,IACpBzP,iBACAlC,OAAOC,SAASgQ,MAEJ2B,SAAW5R,OAAOC,SAAS2R,OAIvC,OAGF5R,OAAO6R,iBAAiB,QAAQ,WAC9B,IAAMxR,EAAK,UAAM6B,iBAAN,sBAEPpC,IAgEV,SAAiCO,EAAeC,GAE9CgM,MAAMjM,EAAO,CACXyR,QAAS,CAAE,iBAAkB,YAE5BpR,MAAK,SAAAoM,GAEJ,IAAMiF,EAAcjF,EAASgF,QAAQpL,IAAI,gBAEnB,MAApBoG,EAASkF,QACO,MAAfD,IAA8D,IAAvCA,EAAYE,QAAQ,cAG5C1R,UAAUC,cAAc0R,MAAMxR,MAAK,SAAAC,GACjCA,EAAawR,aAAazR,MAAK,WAC7BV,OAAOC,SAASmS,eAKpBhS,EAAgBC,EAAOC,MAG1BgB,OAAM,WACLJ,QAAQC,IACN,oEAvFAkR,CAAwBhS,EAAOC,GAI/BC,UAAUC,cAAc0R,MAAMxR,MAAK,WACjCQ,QAAQC,IACN,iHAMJf,EAAgBC,EAAOC,OKmT/BE,K","file":"static/js/main.4ae913ca.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.743a2742.jpeg\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import RemarkMathPlugin from 'remark-math';\nimport remark from 'remark';\nimport strip from 'strip-markdown';\nimport natural from 'natural';\nimport contractions from 'expand-contractions';\nimport { ID } from './model';\n\n/** Associates each word to a number of occurrences in the corpus */\nexport type WordVector = { [key: string]: number }\n\n/**\n * Associates each card ID with the number of times a token occurs in that card.\n */\nexport type Occurrences = { [key: string]: number }\n\n/** \n * Associates each word to the set of cards that contain it\n * and the number of occurrences in that card.\n */\nexport type Index = { [key: string]: Occurrences }\n\nexport function newIndex(): Index {\n    return {};\n}\n\n/**\n * Given some markdown text, return a version of that text minus formatting.\n * @param text \n */\nexport async function removeFormatting(text: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    remark()\n      .use(RemarkMathPlugin)\n      .use(strip)\n      .process(text, function (err, file) {\n        if (err) reject(err);\n        else resolve(String(file));\n      })\n  });\n}\n\n/**\n * Normalizes, tokenizes, removes stop words, and stems the given string.\n * @param text A plain text string\n */\nexport function getFeatures(text: string): WordVector {\n  const expandedText = contractions.expand(text);\n  const tokens = natural.PorterStemmer.tokenizeAndStem(expandedText);\n  const vec: WordVector = {};\n  for (const token of tokens) {\n      vec[token] = vec[token] === undefined ? 1 : vec[token] + 1;\n  }\n  // Normalize\n  for (const token of Object.keys(vec)) {\n      vec[token] = vec[token] / tokens.length\n  }\n  return vec;\n}\n\nfunction addVecToIndex(id: ID, vec: WordVector, index: Index) {\n    for (const [token, count] of Object.entries(vec)) {\n        if (index[token] === undefined) {\n            index[token] = {};\n        }\n        index[token][id] = count;\n    }\n}\n\nfunction removeVecFromIndex(id: ID, vec: WordVector, index: Index) {\n    for (const token of Object.keys(vec)) {\n        if (index[token] !== undefined) {\n            console.log(\"Deleting\", token, \"with count\", index[token][id])\n            delete index[token][id]\n        }\n    }\n}\n\nexport async function addToIndex(id: ID, contents: string, index: Index) {\n    const text = await removeFormatting(contents)\n    const features = getFeatures(text)\n    addVecToIndex(id, features, index);\n}\n\nexport async function removeFromIndex(id: ID, contents: string, index: Index) {\n    const text = await removeFormatting(contents)\n    const features = getFeatures(text)\n    removeVecFromIndex(id, features, index);\n}\n\n/**\n * Computes the similarity of two vectors v1, v2 by taking the dot product.\n * @return A number between 0 and 1; higher is more similar\n */\nfunction cosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let numerator = 0\n    // Note that we only need to iterate over the keys of *one* of the vectors\n    for (const token of Object.keys(vec1)) {\n        numerator += (vec1[token] || 0) * (vec2[token] || 0)\n    } \n    // Since we know both vectors are normalized, the denominator is 1\n    return numerator;\n}\n\n/**\n * Computes the similarity between its inputs.\n * This function is similar to `cosineSimilarity`, but we make sure that\n * a note that matches N keywords always outranks a note matching M < N keywords\n */\nfunction rankedCosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let intersectCount = 0\n    for (const token of Object.keys(vec1)) {\n        if (Object.keys(vec2).includes(token)) {\n            intersectCount += 1\n        }\n\n    }\n    return intersectCount + cosineSimilarity(vec1, vec2)\n}\n\nexport function search(queryString: string, index: Index): ID[] {\n    const query = getFeatures(queryString);\n    if (Object.keys(query).length === 0) return [];\n\n    // We now reconstruct a projection of each document's word vector, only\n    // counting the words that are already in our query.\n\n    // E.g., query = {additive: 0.5, monad: 0.5} and\n    // index = { additive: {\"doc\": 0.2, ...}, monad: {\"doc\": 0.5, ...}, ... }\n    // then documents[\"doc\"] = {additive: 0.2, monad: 0.5}.\n    const documents: Map<ID, WordVector> = new Map();\n    for (const token of Object.keys(query)) {\n        const occurrences = index[token] || {}\n        for (const [id, weight] of Object.entries(occurrences)) {\n            const vec = documents.get(id) || {};\n            vec[token] = weight;\n            documents.set(id, vec)\n        }\n    }\n    // console.log(\"Reconstructed vectors:\", documents)\n\n    // Assign each ID with a similarity score\n    const similarity: [ID, number][] = []\n    for (const [id, vec] of documents.entries()) {\n        similarity.push([id, rankedCosineSimilarity(query, vec)])\n    }\n    // Sort by score, descending\n    similarity.sort((a,b) => b[1] - a[1])\n    // console.log(\"Similarity scores:\", similarity)\n\n    return similarity.map(([id, _]) => id).slice(0,30)\n}","import { v4 as uuid } from 'uuid';\nimport * as Search from './search';\n\nexport type ID = string\nexport type Card = Note | Index\n\nexport type Note = {\n    type: \"note\",\n    contents: string\n}\n\nexport type Index = {\n    type: \"index\",\n    contents: ID[]\n}\n\ntype Database = { [key: string]: Card }\n\nexport type Keypress \n    = 'enter' | 'escape' | 'space' | 'shift+space' | 'backspace'\n    | 'left' | 'right' | 'up' | 'down' | 'back' | 'forward'\n    | 'copy' | 'paste' | 'cut' | 'undo' | 'redo'\n    | 'shift+down' | 'shift+up'\n\nexport function interpretKeypress(key: Keypress, state: State) {\n    if (state.mode === 'viewing') {\n        if (key === 'enter' && state.focus >= 0) {\n            state.mode = 'editing'\n        }\n        else if (key === 'back') {\n            state.goBack()\n        }\n        else if (key === 'forward') {\n            state.goForward()\n        }\n        else if (key === 'space') {\n            const note = state.newNote()\n            state.insertAfter(state.focus, note)\n            state.focus = state.focus + 1\n            state.mode = 'editing'\n        }\n        else if (key === 'paste') {\n            state.paste()\n        }\n        else if (key === 'right' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-outgoing')\n        }\n        else if (key === 'left' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-incoming')\n        }\n    }\n    if (state.mode === 'viewing' || state.mode === 'selecting') {\n        if (key === 'backspace' && state.focus >= 0) {\n            state.removeSelection()\n        }\n        else if (key === 'copy' && state.focus >= 0) {\n            state.copy()\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (key === 'cut' && state.focus >= 0) {\n            state.copy()\n            state.removeSelection()\n        }\n        else if (key === 'escape') {\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (key === 'up') {\n            state.goUp()\n        }\n        else if (key === 'down') {\n            state.goDown()\n        }\n        else if (key === 'shift+down' && state.focus >= 0) {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goDown()\n        }\n        else if (key === 'shift+up') {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goUp()\n        }\n    }\n    if (state.mode === 'editing') {\n        if (key === 'escape') {\n            state.mode = 'viewing'\n        }\n    }\n}\n\nexport const DB_STRING = 'database';\n\nexport type Snapshot = {\n    db: Database,\n    root: ID,\n    timestamp: number\n}\n\nexport class State {\n    // Persistent state\n    db: Database\n    root: ID\n\n    // Temporary state\n    currentIndexID: ID\n    focus: number\n    mode: 'viewing' | 'editing' | 'selecting'\n    clipboard: ID[]\n    selection?: number\n    dirty: boolean\n    index: Search.Index\n\n    constructor(snapshot: Snapshot | null) {\n        if (snapshot === null) {\n            this.root = uuid()\n            this.db = {}\n            this.db[this.root] = { type: 'index', contents: [] }\n        }\n        else {\n            this.root = snapshot.root\n            this.db = snapshot.db\n        }\n        if (window.location.hash !== \"\") {\n            this.currentIndexID = window.location.hash.slice(1)\n            this.focus = window.history.state.focus || -1\n        }\n        else {\n            this.currentIndexID = this.root \n            this.focus = -1\n        }\n        this.mode = 'viewing'\n        this.clipboard = []\n        this.dirty = false;\n\n        // Build index\n        this.index = Search.newIndex();\n        for (const [id, note] of this.notes()) {\n            Search.addToIndex(id, note.contents, this.index);\n        }\n    }\n\n    get snapshot(): Snapshot {\n        return {\n            db: this.db,\n            root: this.root,\n            timestamp: Date.now()\n        }\n    }\n\n    save() {\n        localStorage.setItem(DB_STRING, JSON.stringify(this.snapshot))\n        console.log(\"Saved change to local storage\")\n        this.dirty = true\n    }\n\n    get currentIndex(): Index {\n        return this.db[this.currentIndexID] as Index\n    }\n    get focusedCardID(): ID | undefined {\n        // This is undefined when the focus is -1\n        return this.currentIndex.contents[this.focus]\n    }\n    get focusedCard(): Card | undefined {\n        // This is undefined when the focus is -1\n        return this.focusedCardID ? this.db[this.focusedCardID] : undefined\n    }\n    * notes(): Generator<[ID, Note]> {\n        for (const id in this.db) {\n            if (Object.prototype.hasOwnProperty.call(this.db, id)) {\n                const card = this.db[id];\n                if (card.type === 'note') {\n                    yield [id, card];\n                }\n            }\n        }\n    }\n\n    // NAVIGATION\n\n    view(id: ID, focus: number) {\n        this.currentIndexID = id;\n        this.focus = focus === undefined ? -1 : focus\n    }\n    enter(id: ID) {\n        const focus = this.db[id].contents.length > 0 ? 0 : -1;\n        window.history.replaceState({ focus: this.focus }, \"\", \"#\" + this.currentIndexID);\n        window.history.pushState({focus: focus}, \"\", \"#\" + id);\n        this.view(id, focus)\n    }\n    goBack() {\n        window.history.back()\n    }\n    goForward() {\n        window.history.forward()\n    }\n    goUp() {\n        // The behavior in 'selecting' mode and 'viewing' mode is\n        // slightly different: when selecting, you cannot move the\n        // focus any higher than 0.\n        if (this.mode === 'viewing') {\n            if (this.focus > -1) {\n                this.focus = this.focus - 1\n            }\n        }\n        if (this.mode === 'selecting') {\n            if (this.focus > 0) {\n                this.focus = this.focus - 1\n            }\n        }\n    }\n    goDown() {\n        if (this.focus < this.currentIndex.contents.length - 1) {\n            this.focus = this.focus + 1\n        }\n    }\n\n    // MUTATION\n\n    search(query: string) {\n        const results = Search.search(query, this.index)\n        const id = this.newIndex()\n        const index = this.db[id]!\n        index.contents = results\n        this.enter(id)\n        this.save()\n    }\n    updateNote(id : ID, contents : string): boolean {\n        const note = this.db[id]\n        if (note && note.type === 'note') {\n            note.contents = contents\n            return true\n        }\n        else {\n            return false\n        }\n    }\n    insertAfter(focus: number, id: ID) {\n        this.currentIndex.contents.splice(focus + 1, 0, id)\n\n        // If this note is added to the outgoing links of another\n        // note, then add the latter to the *incoming* links of the former.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const incomingIndex = this.db[id + \"-incoming\"] as Index\n            incomingIndex.contents.push(note)\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const outgoingIndex = this.db[id + \"-outgoing\"] as Index\n            outgoingIndex.contents.push(note)\n        }\n        this.save()\n    }\n    remove(focus: number) {\n        const id = this.currentIndex.contents[focus]\n        this.currentIndex.contents.splice(focus, 1)\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n\n        // If this note was deleted from the outgoing links of\n        // another note, then we should also remove that note\n        // from the incoming links of this note.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const incomingIndex = this.db[id + \"-incoming\"] as Index\n            const focus = incomingIndex.contents.findIndex(x => x === note)\n            incomingIndex.contents.splice(focus, 1)\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const outgoingIndex = this.db[id + \"-outgoing\"] as Index\n            const focus = outgoingIndex.contents.findIndex(x => x === note)\n            outgoingIndex.contents.splice(focus, 1)\n        }\n        this.save()\n    }\n    newNote(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'note', contents: \"\"}\n        this.db[id + \"-incoming\"] = {type: 'index', contents: []}\n        this.db[id + \"-outgoing\"] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    newIndex(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    removeSelection() {\n        if (this.mode === 'viewing') {\n            this.remove(this.focus)\n        }\n        else if (this.mode === 'selecting') {\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            for (let i = lower; i <= upper; i++) {\n                // Delete the lowest index, and the next note\n                // to delete will be moved to that element. \n                this.remove(lower);\n            }\n            this.mode = 'viewing'\n            this.selection = undefined\n            this.focus = lower\n        }\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n    }\n    copy() {\n        if (this.mode === 'viewing') {\n            this.clipboard = [this.focusedCardID!]\n        }\n        else if (this.mode === 'selecting') {\n            const index = this.currentIndex\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            this.clipboard = []\n            for (let i = lower; i <= upper; i++) {\n                this.clipboard.push(index.contents[i])\n            }\n        }\n    }\n    paste() {\n        for (let i = 0; i < this.clipboard.length; i++) {\n            this.insertAfter(this.focus + i, this.clipboard[i])\n        }\n    }\n}","import React, { useMemo, useState } from 'react'\nimport { createEditor, Node } from 'slate'\nimport { Slate, Editable, withReact } from 'slate-react'\nimport { withHistory } from 'slate-history'\nimport { Note, ID } from './model'\n\ntype Props = { \n  note: Note, \n  id: ID, \n  updateNote: (id : ID, contents : string) => void,\n  onKeyDown: (e: React.KeyboardEvent) => void\n}\nconst NoteEditor = (props: Props) => {\n  const [value, setValue] = useState<Node[]>(deserialize(props.note.contents))\n  const editor = useMemo(() => withHistory(withReact(createEditor())), [])\n\n  function onChange(value: Node[]) {\n    setValue(value)\n    props.updateNote(props.id, serialize(value))\n  }\n\n  return (\n    <Slate editor={editor} value={value} onChange={onChange}>\n      <Editable autoFocus \n        onKeyDown={props.onKeyDown} \n        placeholder=\"Enter some text...\" \n        style={{marginTop: '14px', marginBottom: '14px'}}\n      />\n    </Slate>\n  )\n}\n\n// Define a serializing function that takes a value and returns a string.\nconst serialize = (value: Node[]) => {\n  return (\n    value\n      // Return the string content of each paragraph in the value's children.\n      .map(n => Node.string(n))\n      // Join them all with line breaks denoting paragraphs.\n      .join('\\n')\n  )\n}\n\n// Define a deserializing function that takes a string and returns a value.\nconst deserialize = (string: any): Node[] => {\n  // Return a value array of children derived by splitting the string.\n  return string.split('\\n').map((line: string) => {\n    return {\n      children: [{ text: line }],\n    }\n  })\n}\n\nexport default NoteEditor","import fetch from \"isomorphic-fetch\";\nimport { Dropbox } from \"dropbox\";\nimport { State, Snapshot } from \"./model\";\n\n/**\n * This code is based on the dropbox API examples:\n * https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/auth/index.html\n */\n\nconst DROPBOX_APP_KEY = \"31ybvx3rsag1cih\";\nconst CLOUD_PATH = \"/database.json\";\nconst ACCESS_TOKEN_COOKIE = \"dropbox_access_token\"\n\n// SOURCE: https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/utils.js\nfunction parseQueryString(str: string) {\n  var ret = Object.create(null);\n\n  if (typeof str !== \"string\") {\n    return ret;\n  }\n\n  str = str.trim().replace(/^(\\?|#|&)/, \"\");\n\n  if (!str) {\n    return ret;\n  }\n\n  str.split(\"&\").forEach(function (param) {\n    var parts = param.replace(/\\+/g, \" \").split(\"=\");\n    // Firefox (pre 40) decodes `%3D` to `=`\n    // https://github.com/sindresorhus/query-string/pull/37\n    var key = parts.shift();\n    var val = parts.length > 0 ? parts.join(\"=\") : undefined;\n\n    key = decodeURIComponent(key!);\n\n    // missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n    var val2 = val === undefined ? null : decodeURIComponent(val);\n\n    if (ret[key] === undefined) {\n      ret[key] = val2;\n    } else if (Array.isArray(ret[key])) {\n      ret[key].push(val2);\n    } else {\n      ret[key] = [ret[key], val2];\n    }\n  });\n\n  return ret;\n}\n\nfunction readBlob(blob: Blob): Promise<string | ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = function (evt) {\n        if (evt && evt.target && evt.target.result) {\n          resolve(evt.target.result);\n        } else {\n          reject(\n            \"Blob had an unexpected format: blob.target.result is undefined\\n\" +\n              evt\n          );\n        }\n      };\n      reader.onerror = function (err) {\n        reject(err);\n      };\n      reader.readAsText(blob);\n    });\n  }\n\n// Fetch the access token from local storage, or else check if\n// it is in the URL as a result of OAuth\nfunction getAccessToken() {\n  const cached_token = localStorage.getItem(ACCESS_TOKEN_COOKIE)\n  if (cached_token !== null) {\n    return cached_token;\n  }\n\n  const url_token = parseQueryString(window.location.hash).access_token\n  if (url_token) {\n    localStorage.setItem(ACCESS_TOKEN_COOKIE, url_token)\n  }\n  return url_token\n}\n\nexport function isAuthenticated() {\n  return !!getAccessToken();\n}\n\nconst dbx = isAuthenticated() \n    ? new Dropbox({ fetch, accessToken: getAccessToken() })\n    : new Dropbox({ fetch, clientId: DROPBOX_APP_KEY });\n\nasync function upload(state: State): Promise<void> {\n    try {\n        state.dirty = false;\n        const result = await dbx.filesUpload({\n            contents: JSON.stringify(state.snapshot),\n            path: CLOUD_PATH,\n            mode: { \".tag\": \"overwrite\" },\n            mute: true,\n        })\n        console.log(\"Upload successful\");\n        console.log(result);\n    }\n    catch (e) {\n        console.error(\"Upload failed!\");\n        console.error(e);\n        state.dirty = true;\n    }\n}\n\nasync function download(): Promise<Snapshot | null> {\n    try {\n        const result   = await dbx.filesDownload({ path: CLOUD_PATH }) as any;\n        const response = await readBlob(result.fileBlob) as string\n        const snapshot = JSON.parse(response) as Snapshot;\n        return snapshot;\n    } catch (err) {\n        console.error(\"Error fetching data from cloud:\");\n        console.error(err);\n        return null;\n    }\n}\n\nexport type AuthenticatedCloud = {\n    isAuthenticated: true,\n    upload: (state: State) => Promise<void>,\n    download: () => Promise<Snapshot | null>\n}\n\nexport type UnauthenticatedCloud = {\n    isAuthenticated: false,\n    authenticationURL: string\n}\n\nexport type Cloud = AuthenticatedCloud | UnauthenticatedCloud\n\nconst Cloud: Cloud = isAuthenticated() ? \n    {\n        isAuthenticated: true,\n        upload, download\n    }\n    :\n    {\n        isAuthenticated: false,\n        authenticationURL: dbx.getAuthenticationUrl(window.location.toString())\n    }\n\nexport default Cloud\n\n\n","import React, { useRef, useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactMarkdown from 'react-markdown';\nimport RemarkMathPlugin from 'remark-math';\nimport RemarkHighlightPlugin from 'remark-highlight.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport Hotkeys from 'react-hot-keys';\nimport './index.scss';\nimport * as serviceWorker from './serviceWorker';\nimport { State, interpretKeypress, Card, Keypress, ID, Index, Note, Snapshot, DB_STRING } from './model';\nimport 'materialize-css/dist/js/materialize.min.js';\nimport 'katex/dist/katex.min.css';\nimport NoteEditor from './NoteEditor';\nimport Dropbox, { AuthenticatedCloud } from './cloud';\nimport logo from './logo.jpeg';\n\n\ntype CardProps = { card: Card, id: ID, state: State, isFocused: boolean, isSelected: boolean }\ntype PreviewProps = { card: Card, id: ID, state: State }\n\nfunction onKeyDown(e: React.KeyboardEvent) {\n  if (state) {\n    if (e.key === 'Escape') {\n      state.mode = 'viewing'\n      state.save()\n      render()\n    }\n  }\n}\n\nfunction scrollToElement(el : HTMLElement) {\n  el.scrollIntoView({behavior: \"smooth\", block: \"center\"})\n}\n\nfunction EditNote(\n  props: { note: Note, id: ID }\n): JSX.Element {\n\n  const {note, id} = props\n  const ref: React.MutableRefObject<HTMLTextAreaElement | null> = useRef(null)\n\n  if (ref.current)\n    scrollToElement(ref.current)\n\n  return (\n    <div className=\"card-panel z-depth-3 edited-note\">\n      <NoteEditor note={note} id={id} updateNote={updateNote} onKeyDown={onKeyDown} />\n    </div>\n  )\n}\n\nconst MarkdownRenderers: ReactMarkdown.Renderers = {\n  math: ({value}) => <BlockMath>{value}</BlockMath>,\n  inlineMath: ({ value }) => <InlineMath>{value}</InlineMath>,\n  code: ({language, value}) => <SyntaxHighlighter language={language} style={docco}>{value}</SyntaxHighlighter>\n}\n\nfunction ViewNote(\n  props: { card: Note, id: ID, state: State, isFocused: boolean, isSelected: boolean }\n): JSX.Element {\n\n  const ifFocused = props.isFocused ? \"z-depth-3\" : \"\";\n  const ifSelected = props.isSelected ? \"blue lighten-5\" : \"\";\n  const className = [\"card-panel\", ifFocused, ifSelected].join(\" \");\n\n  const ref: React.MutableRefObject<HTMLDivElement | null> = useRef(null)\n\n  useEffect( () => {\n    const el = ref.current\n    if (el && props.isFocused) {\n      console.log(\"Scrolling to\", props.id);\n\n      setTimeout(() => {\n        scrollToElement(el)\n      }, 20)\n    }\n  })\n\n  return (\n    <div className={className} ref={ref}>\n      <ReactMarkdown \n        source={props.card.contents}\n        plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n        renderers={MarkdownRenderers as any}\n      />\n    </div>\n  )\n}\n\nfunction RenderCard(props: CardProps): JSX.Element {\n  const {card, id, state, isFocused} = props;\n\n  if (card.type === 'index') {\n    return (\n      <div>\n        {`Index: (${card.contents.length} cards)`}\n      </div>\n    )\n  }\n  else {\n\n    if (isFocused && state.mode === 'editing') {\n      return (\n        <EditNote note={card} id={id} />\n      )\n    }\n    else {\n      return (\n        <ViewNote {...props} card={card} />\n      )\n    }\n  }\n}\n\nfunction CardPreview({card, id, state}: PreviewProps): JSX.Element {\n  if (card.type === 'index') {\n    return (\n      <div className=\"card-panel truncate\">\n        {`Index: (${card.contents.length} cards)`}\n      </div>\n    )\n  }\n  else {\n    const words = card.contents.split(\" \");\n    const preview = words.length > 20 \n      ? words.slice(0,20).join(\" \") + \"...\" \n      : card.contents;\n\n    return (\n      <div className=\"card-panel\">\n        <ReactMarkdown \n          source={preview}\n          plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n          renderers={MarkdownRenderers as any}\n        />\n      </div>\n    )\n  }\n}\n\nfunction Search({state}: {state: State | null}): JSX.Element {\n  const [query, setQuery] = useState(\"\");\n  const ref: React.MutableRefObject<HTMLInputElement | null> = useRef(null)\n\n  function onSubmit(event: React.SyntheticEvent) {\n    event.preventDefault()\n    if (state) {\n      state.search(query)\n      render()\n      if (ref.current) ref.current.blur()\n    }\n  }\n  function onKeyDown(e: React.KeyboardEvent) {\n    if (e.key === 'Escape') {\n      if (ref.current) ref.current.blur()\n    }\n  }\n\n  return (\n    <form className=\"input-field\" onSubmit={onSubmit}>\n      <i className=\"material-icons prefix\">search</i>\n      <input id=\"icon_prefix\" type=\"text\" ref={ref}\n        onChange={ e => setQuery(e.target.value) } \n        onKeyDown={onKeyDown} />\n      <label htmlFor=\"icon_prefix\">Search</label>\n    </form>\n  )\n}\n\nfunction Editor({state}: {state: State | null}): JSX.Element {\n\n  if (state === null) {\n    return (\n      <div className=\"row\">\n        <div className=\"col s3 offset-s4\">\n          <div className=\"card-panel valign-wrapper\">\n            <b className=\"center-align\">Loading...</b>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  const cards = state.currentIndex.contents\n  const focusedID = cards[state.focus]\n  const outgoing = state.db[focusedID + \"-outgoing\"] as Index | undefined\n  const incoming = state.db[focusedID + \"-incoming\"] as Index | undefined\n\n  return (\n    <div className=\"row\">\n      <div id=\"left-panel\" className=\"pinned col l3 offset-l1 m3 hide-on-small-only\">\n        <a href=\"/\"><img id=\"logo\" src={logo} alt=\"Go home\" /></a>\n        {incoming && incoming.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} id={id} state={state} />\n        })}\n      </div>\n      <div id=\"main-panel\" className=\"col l4 offset-l4 m6 offset-m3 s10 offset-s1\"> \n        <Search state={state} />\n        {\n          Dropbox.isAuthenticated ||\n          <div className=\"card-panel\">\n            <a href={Dropbox.authenticationURL}>Sign in to Dropbox</a>\n          </div>  \n        }\n        {cards.map(function (id: ID, i: number) {\n            const card = state.db[id]\n            const isFocused = state.focus === i\n            const isSelected = state.mode === 'selecting' &&\n              ((state.focus <= i && i <= state.selection!) ||\n              (state.focus >= i && i >= state.selection!))\n\n\n            return <RenderCard id={id} card={card} key={i} state={state} isFocused={isFocused} isSelected={isSelected} />\n        })}\n      </div>\n      <div id=\"right-panel\" className=\"pinned col l3 offset-l8 m3 offset-m9 hide-on-small-only\">\n        {outgoing && outgoing.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} id={id} state={state} />\n        })}\n      </div>\n    </div>\n  )\n}\n\nconst keymap : { [key: string] : Keypress} = {\n  'Enter': 'enter',\n  'command+c': 'copy',\n  'command+x': 'cut',\n  'command+v': 'paste',\n  'command+z': 'undo',\n  'command+shift+z': 'redo',\n  'Space': 'space',\n  'right': 'right',\n  'left': 'left',\n  'up': 'up',\n  'down': 'down',\n  'Escape': 'back',\n  'Backspace': 'backspace',\n  'shift+down': 'shift+down',\n  'shift+up': 'shift+up',\n  // VIM keybindings\n  'j': 'down',\n  'k': 'up',\n  'h': 'left',\n  'l': 'right',\n  'shift+h': 'back',\n  'shift+l': 'forward',\n  'u': 'undo',\n  'ctrl+r': 'redo',\n  'y': 'copy',\n  'p': 'paste',\n  'x': 'cut',\n  'd': 'backspace',\n  'i': 'enter',\n  'a': 'space'\n}\n\nconst boundKeys = Object.keys(keymap).join(\",\")\n\nfunction App() {\n  return (\n    <Hotkeys\n      keyName={boundKeys}\n      onKeyDown={handleKey}\n    >\n      <Editor state={state}/>\n    </Hotkeys>\n  );\n}\n\n\n\nlet state : State | null = null;\n\n// Periodically upload state to Dropbox\n\nif (Dropbox.isAuthenticated) {\n  setInterval(() => {\n    if (state !== null && state.dirty)\n      (Dropbox as AuthenticatedCloud).upload(state)\n  }, 10000)\n}\n\n\n// Initialize state, checking Dropbox and localStorage\n\n(async function () {\n  const cloudSnapshot = Dropbox.isAuthenticated ? await Dropbox.download() : null\n  cloudSnapshot && console.log(\"Got cloud snapshot:\", cloudSnapshot)\n\n  const text = localStorage.getItem(DB_STRING)\n  const localSnapshot = text ? JSON.parse(text) as Snapshot : null\n  console.log(\"Got snapshot from localstorage:\", localSnapshot)\n\n  // No previous work found... Start in the initial state.\n  if (localSnapshot === null && cloudSnapshot === null) {\n    state = new State(null);\n  }\n  // Cloud backup found, with no local save. Must be logging in on a new browser or cleared the cache.\n  else if (localSnapshot === null && cloudSnapshot !== null) {\n    state = new State(cloudSnapshot);\n  }\n  // If a local copy is found with no cloud backup, then load that local state.\n  else if (localSnapshot !== null && cloudSnapshot === null) {\n    state = new State(localSnapshot);\n  }\n  // At this point we know that both a local snapshot and a cloud snapshot exist.\n  // Load whichever one has the more recent time stamp.\n  else {\n    state = (localSnapshot!.timestamp < cloudSnapshot!.timestamp) \n      ? new State(cloudSnapshot) \n      : new State(localSnapshot);\n  }\n\n  render();\n\n})()\n\n\nfunction handleKey(key: string, event: any) {\n  if (state) {\n    // Prevent the default refresh event under WINDOWS system\n    event.preventDefault() \n    console.log(keymap[key]) \n    interpretKeypress(keymap[key], state);\n    console.log(state)\n    render()\n  }\n}; \n\nfunction updateNote(id : ID, contents : string) {\n  if (state) {\n    if (state.updateNote(id, contents)) {\n      render()\n    }\n    else {\n      console.error(`Cannot update card ${id}: not a note`)\n    }\n  }\n}\n\nfunction render() {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n  );  \n}\n\nwindow.onpopstate = function (e: PopStateEvent) {\n  console.log(\"Entered index \" + window.location.hash + \" focus \" + e.state.focus)\n  if (state) {\n    state.view(window.location.hash.slice(1), e.state.focus)\n    render()\n  }\n}\n\nrender()\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();"],"sourceRoot":""}