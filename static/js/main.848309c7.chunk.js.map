{"version":3,"sources":["logo.jpeg","serviceWorker.ts","search.ts","model.ts","NoteEditor.tsx","cloud.ts","index.tsx"],"names":["module","exports","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","navigator","serviceWorker","register","then","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","onUpdate","onSuccess","catch","error","removeFormatting","text","a","Promise","resolve","reject","remark","use","RemarkMathPlugin","strip","process","err","file","String","getFeatures","expandedText","contractions","expand","tokens","natural","PorterStemmer","tokenizeAndStem","vec","token","undefined","Object","keys","length","addVecToIndex","id","index","entries","count","addToIndex","contents","features","cosineSimilarity","vec1","vec2","numerator","State","snapshot","db","root","crumbs","mode","clipboard","selection","dirty","this","uuid","type","notes","Search","localStorage","setItem","JSON","stringify","prototype","hasOwnProperty","call","card","focus","push","pop","currentIndex","query","results","queryString","documents","Map","occurrences","weight","get","set","similarity","sort","b","map","newIndex","enter","save","note","splice","indexID","currentIndexID","endsWith","substr","incomingIndex","findIndex","x","outgoingIndex","remove","lower","Math","min","upper","max","i","focusedCardID","insertAfter","timestamp","Date","now","serialize","value","n","Node","string","join","deserialize","split","line","children","NoteEditor","props","useState","setValue","editor","useMemo","withHistory","withReact","createEditor","onChange","updateNote","autoFocus","onKeyDown","placeholder","style","marginTop","marginBottom","readBlob","blob","reader","FileReader","onload","evt","target","result","onerror","readAsText","getAccessToken","cached_token","getItem","url_token","str","ret","create","trim","replace","forEach","param","parts","key","shift","val","decodeURIComponent","val2","Array","isArray","parseQueryString","hash","access_token","isAuthenticated","dbx","Dropbox","fetch","accessToken","clientId","filesUpload","path","mute","filesDownload","fileBlob","response","parse","Cloud","upload","download","authenticationURL","getAuthenticationUrl","toString","e","render","scrollToElement","el","scrollIntoView","behavior","block","EditNote","ref","useRef","current","className","MarkdownRenderers","math","inlineMath","code","language","docco","ViewNote","isFocused","isSelected","useEffect","setTimeout","source","plugins","RemarkHighlightPlugin","renderers","RenderCard","CardPreview","words","preview","slice","setQuery","onSubmit","event","preventDefault","search","blur","htmlFor","Editor","cards","focusedID","outgoing","incoming","src","logo","display","margin","width","href","keymap","boundKeys","App","keyName","handleKey","exit","newNote","paste","removeSelection","copy","goUp","goDown","interpretKeypress","ReactDOM","StrictMode","document","getElementById","setInterval","cloudSnapshot","localSnapshot","URL","origin","addEventListener","headers","contentType","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.848309c7.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.743a2742.jpeg\";","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import RemarkMathPlugin from 'remark-math';\nimport remark from 'remark';\nimport strip from 'strip-markdown';\nimport natural from 'natural';\nimport contractions from 'expand-contractions';\nimport { ID } from './model';\n\n/** Associates each word to a number of occurrences in the corpus */\nexport type WordVector = { [key: string]: number }\n\n/**\n * Associates each card ID with the number of times a token occurs in that card.\n */\nexport type Occurrences = { [key: string]: number }\n\n/** \n * Associates each word to the set of cards that contain it\n * and the number of occurrences in that card.\n */\nexport type Index = { [key: string]: Occurrences }\n\nexport function newIndex(): Index {\n    return {};\n}\n\n/**\n * Given some markdown text, return a version of that text minus formatting.\n * @param text \n */\nexport async function removeFormatting(text: string): Promise<string> {\n  return new Promise((resolve, reject) => {\n    remark()\n      .use(RemarkMathPlugin)\n      .use(strip)\n      .process(text, function (err, file) {\n        if (err) reject(err);\n        else resolve(String(file));\n      })\n  });\n}\n\n/**\n * Normalizes, tokenizes, removes stop words, and stems the given string.\n * @param text A plain text string\n */\nexport function getFeatures(text: string): WordVector {\n  const expandedText = contractions.expand(text);\n  const tokens = natural.PorterStemmer.tokenizeAndStem(expandedText);\n  const vec: WordVector = {};\n  for (const token of tokens) {\n      vec[token] = vec[token] === undefined ? 1 : vec[token] + 1;\n  }\n  // Normalize\n  for (const token of Object.keys(vec)) {\n      vec[token] = vec[token] / tokens.length\n  }\n  return vec;\n}\n\nfunction addVecToIndex(id: ID, vec: WordVector, index: Index) {\n    for (const [token, count] of Object.entries(vec)) {\n        if (index[token] === undefined) {\n            index[token] = {};\n        }\n        index[token][id] = count;\n    }\n}\n\nfunction removeVecFromIndex(id: ID, vec: WordVector, index: Index) {\n    for (const token of Object.keys(vec)) {\n        if (index[token] !== undefined) {\n            console.log(\"Deleting\", token, \"with count\", index[token][id])\n            delete index[token][id]\n        }\n    }\n}\n\nexport async function addToIndex(id: ID, contents: string, index: Index) {\n    const text = await removeFormatting(contents)\n    const features = getFeatures(text)\n    addVecToIndex(id, features, index);\n}\n\nexport async function removeFromIndex(id: ID, contents: string, index: Index) {\n    const text = await removeFormatting(contents)\n    const features = getFeatures(text)\n    removeVecFromIndex(id, features, index);\n}\n\n/**\n * Computes the similarity of two vectors v1, v2 by taking the dot product.\n * @return A number between 0 and 1; higher is more similar\n */\nfunction cosineSimilarity(vec1: WordVector, vec2: WordVector): number {\n    let numerator = 0\n    // Note that we only need to iterate over the keys of *one* of the vectors\n    for (const token of Object.keys(vec1)) {\n        numerator += (vec1[token] || 0) * (vec2[token] || 0)\n    } \n    // Since we know both vectors are normalized, the denominator is 1\n    return numerator;\n}\n\nexport function search(queryString: string, index: Index): ID[] {\n    const query = getFeatures(queryString);\n    if (Object.keys(query).length == 0) return [];\n\n    // We now reconstruct a projection of each document's word vector, only\n    // counting the words that are already in our query.\n\n    // E.g., query = {additive: 0.5, monad: 0.5} and\n    // index = { additive: {\"doc\": 0.2, ...}, monad: {\"doc\": 0.5, ...}, ... }\n    // then documents[\"doc\"] = {additive: 0.2, monad: 0.5}.\n    const documents: Map<ID, WordVector> = new Map();\n    for (const token of Object.keys(query)) {\n        const occurrences = index[token] || {}\n        for (const [id, weight] of Object.entries(occurrences)) {\n            const vec = documents.get(id) || {};\n            vec[token] = weight;\n            documents.set(id, vec)\n        }\n    }\n    // console.log(\"Reconstructed vectors:\", documents)\n\n    // Assign each ID with a similarity score\n    const similarity: [ID, number][] = []\n    for (const [id, vec] of documents.entries()) {\n        similarity.push([id, cosineSimilarity(query, vec)])\n    }\n    // Sort by score, descending\n    similarity.sort((a,b) => b[1] - a[1])\n    // console.log(\"Similarity scores:\", similarity)\n\n    return similarity.map(([id, _]) => id)\n}","import { v4 as uuid } from 'uuid';\nimport * as Search from './search';\n\nexport type ID = string\nexport type Card = Note | Index\n\nexport type Note = {\n    type: \"note\",\n    contents: string\n}\n\nexport type Index = {\n    type: \"index\",\n    contents: ID[]\n}\n\ntype Database = { [key: string]: Card }\n\ntype Breadcrumbs = [ID, number][]\n\nexport type Keypress \n    = 'enter' | 'escape' | 'space' | 'shift+space' | 'backspace'\n    | 'left' | 'right' | 'up' | 'down' \n    | 'copy' | 'paste' | 'cut' | 'undo' | 'redo'\n    | 'shift+down' | 'shift+up'\n\nexport function interpretKeypress(key: Keypress, state: State) {\n    if (state.mode === 'viewing') {\n        if (key === 'enter' && state.focus >= 0) {\n            state.mode = 'editing'\n        }\n        else if (key === 'escape') {\n            state.exit()\n        }\n        else if (key === 'space') {\n            const note = state.newNote()\n            state.insertAfter(state.focus, note)\n            state.focus = state.focus + 1\n            state.mode = 'editing'\n        }\n        else if (key === 'paste') {\n            state.paste()\n        }\n        else if (key === 'right' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-outgoing')\n        }\n        else if (key === 'left' && state.focus >= 0) {\n            const note = state.currentIndex.contents[state.focus]\n            state.enter(note + '-incoming')\n        }\n    }\n    if (state.mode === 'viewing' || state.mode === 'selecting') {\n        if (key === 'backspace' && state.focus >= 0) {\n            state.removeSelection()\n        }\n        else if (key === 'copy' && state.focus >= 0) {\n            state.copy()\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (key === 'cut' && state.focus >= 0) {\n            state.copy()\n            state.removeSelection()\n        }\n        else if (key === 'escape') {\n            state.mode = 'viewing'\n            state.selection = undefined\n        }\n        else if (key === 'up') {\n            state.goUp()\n        }\n        else if (key === 'down') {\n            state.goDown()\n        }\n        else if (key === 'shift+down' && state.focus >= 0) {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goDown()\n        }\n        else if (key === 'shift+up') {\n            state.mode = 'selecting'\n            if (state.selection === undefined) {\n                state.selection = state.focus\n            }\n            state.goUp()\n        }\n    }\n    if (state.mode === 'editing') {\n        if (key === 'escape') {\n            state.mode = 'viewing'\n        }\n    }\n}\n\nexport const DB_STRING = 'database';\n\nexport type Snapshot = {\n    db: Database,\n    root: ID,\n    timestamp: number\n}\n\nexport class State {\n    // Persistent state\n    db: Database\n    root: ID\n\n    // Temporary state\n    crumbs: Breadcrumbs\n    mode: 'viewing' | 'editing' | 'selecting'\n    clipboard: ID[]\n    selection?: number\n    dirty: boolean\n    index: Search.Index\n\n    constructor(snapshot: Snapshot | null) {\n        if (snapshot === null) {\n            this.root = uuid()\n            this.db = {}\n            this.db[this.root] = { type: 'index', contents: [] }\n        }\n        else {\n            this.root = snapshot.root\n            this.db = snapshot.db\n        }\n        this.crumbs = [[this.root, -1]]\n        this.mode = 'viewing'\n        this.clipboard = []\n        this.dirty = false;\n\n        // Build index\n        this.index = Search.newIndex();\n        for (const [id, note] of this.notes()) {\n            Search.addToIndex(id, note.contents, this.index);\n        }\n\n        // // Test\n        // setTimeout(() => {\n        //     console.log(Search.search({neural: 0.5, network: 0.5}, this.index))\n        // }, 5000);\n    }\n\n    get snapshot(): Snapshot {\n        return {\n            db: this.db,\n            root: this.root,\n            timestamp: Date.now()\n        }\n    }\n\n    save() {\n        localStorage.setItem(DB_STRING, JSON.stringify(this.snapshot))\n        console.log(\"Saved change to local storage\")\n        this.dirty = true\n    }\n\n    get focus(): number {\n        return this.crumbs[this.crumbs.length - 1][1]\n    }\n    set focus(focus: number) {\n        this.crumbs[this.crumbs.length - 1][1] = focus\n    }\n    get currentIndexID(): ID {\n        return this.crumbs[this.crumbs.length - 1][0]\n    }\n    get currentIndex(): Index {\n        return this.db[this.currentIndexID] as Index\n    }\n    get focusedCardID(): ID | undefined {\n        // This is undefined when the focus is -1\n        return this.currentIndex.contents[this.focus]\n    }\n    get focusedCard(): Card | undefined {\n        // This is undefined when the focus is -1\n        return this.focusedCardID ? this.db[this.focusedCardID] : undefined\n    }\n    * notes(): Generator<[ID, Note]> {\n        for (const id in this.db) {\n            if (Object.prototype.hasOwnProperty.call(this.db, id)) {\n                const card = this.db[id];\n                if (card.type === 'note') {\n                    yield [id, card];\n                }\n            }\n        }\n    }\n\n    // NAVIGATION\n\n    enter(id: ID) {\n        let focus\n        if (this.db[id].contents.length > 0) {\n            focus = 0\n        }\n        else {\n            focus = -1\n        }\n        this.crumbs.push([id, focus])\n    }\n    exit() {\n        if (this.crumbs.length > 1) {\n            this.crumbs.pop()\n        }\n    }\n    goUp() {\n        // The behavior in 'selecting' mode and 'viewing' mode is\n        // slightly different: when selecting, you cannot move the\n        // focus any higher than 0.\n        if (this.mode === 'viewing') {\n            if (this.focus > -1) {\n                this.focus = this.focus - 1\n            }\n        }\n        if (this.mode === 'selecting') {\n            if (this.focus > 0) {\n                this.focus = this.focus - 1\n            }\n        }\n    }\n    goDown() {\n        if (this.focus < this.currentIndex.contents.length - 1) {\n            this.focus = this.focus + 1\n        }\n    }\n\n    // MUTATION\n\n    search(query: string) {\n        const results = Search.search(query, this.index)\n        const id = this.newIndex()\n        const index = this.db[id]!\n        index.contents = results\n        this.enter(id)\n        this.save()\n    }\n    updateNote(id : ID, contents : string): boolean {\n        const note = this.db[id]\n        if (note && note.type === 'note') {\n            note.contents = contents\n            return true\n        }\n        else {\n            return false\n        }\n    }\n    insertAfter(focus: number, id: ID) {\n        this.currentIndex.contents.splice(focus + 1, 0, id)\n\n        // If this note is added to the outgoing links of another\n        // note, then add the latter to the *incoming* links of the former.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const incomingIndex = this.db[id + \"-incoming\"] as Index\n            incomingIndex.contents.push(note)\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const outgoingIndex = this.db[id + \"-outgoing\"] as Index\n            outgoingIndex.contents.push(note)\n        }\n        this.save()\n    }\n    remove(focus: number) {\n        const id = this.currentIndex.contents[focus]\n        this.currentIndex.contents.splice(focus, 1)\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n\n        // If this note was deleted from the outgoing links of\n        // another note, then we should also remove that note\n        // from the incoming links of this note.\n        const indexID = this.currentIndexID;\n        if (indexID.endsWith(\"-outgoing\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const incomingIndex = this.db[id + \"-incoming\"] as Index\n            const focus = incomingIndex.contents.findIndex(x => x === note)\n            incomingIndex.contents.splice(focus, 1)\n        }\n        if (indexID.endsWith(\"-incoming\")) {\n            const note : ID = indexID.substr(0, indexID.length - 9)\n            const outgoingIndex = this.db[id + \"-outgoing\"] as Index\n            const focus = outgoingIndex.contents.findIndex(x => x === note)\n            outgoingIndex.contents.splice(focus, 1)\n        }\n        this.save()\n    }\n    newNote(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'note', contents: \"\"}\n        this.db[id + \"-incoming\"] = {type: 'index', contents: []}\n        this.db[id + \"-outgoing\"] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    newIndex(): ID {\n        const id = uuid()\n        this.db[id] = {type: 'index', contents: []}\n        this.save()\n        return id\n    }\n    removeSelection() {\n        if (this.mode === 'viewing') {\n            this.remove(this.focus)\n        }\n        else if (this.mode === 'selecting') {\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            for (let i = lower; i <= upper; i++) {\n                // Delete the lowest index, and the next note\n                // to delete will be moved to that element. \n                this.remove(lower);\n            }\n            this.mode = 'viewing'\n            this.selection = undefined\n            this.focus = lower\n        }\n        // Update the focus if it's now out of bounds\n        if (this.focus > this.currentIndex.contents.length - 1) {\n            this.focus = this.focus - 1\n        }\n    }\n    copy() {\n        if (this.mode === 'viewing') {\n            this.clipboard = [this.focusedCardID!]\n        }\n        else if (this.mode === 'selecting') {\n            const index = this.currentIndex\n            const lower = Math.min(this.focus, this.selection!)\n            const upper = Math.max(this.focus, this.selection!)\n            this.clipboard = []\n            for (let i = lower; i <= upper; i++) {\n                this.clipboard.push(index.contents[i])\n            }\n        }\n    }\n    paste() {\n        for (let i = 0; i < this.clipboard.length; i++) {\n            this.insertAfter(this.focus + i, this.clipboard[i])\n        }\n    }\n}","import React, { useMemo, useState } from 'react'\nimport { createEditor, Node } from 'slate'\nimport { Slate, Editable, withReact } from 'slate-react'\nimport { withHistory } from 'slate-history'\nimport { Note, ID } from './model'\n\ntype Props = { \n  note: Note, \n  id: ID, \n  updateNote: (id : ID, contents : string) => void,\n  onKeyDown: (e: React.KeyboardEvent) => void\n}\nconst NoteEditor = (props: Props) => {\n  const [value, setValue] = useState<Node[]>(deserialize(props.note.contents))\n  const editor = useMemo(() => withHistory(withReact(createEditor())), [])\n\n  function onChange(value: Node[]) {\n    setValue(value)\n    props.updateNote(props.id, serialize(value))\n  }\n\n  return (\n    <Slate editor={editor} value={value} onChange={onChange}>\n      <Editable autoFocus \n        onKeyDown={props.onKeyDown} \n        placeholder=\"Enter some text...\" \n        style={{marginTop: '14px', marginBottom: '14px'}}\n      />\n    </Slate>\n  )\n}\n\n// Define a serializing function that takes a value and returns a string.\nconst serialize = (value: Node[]) => {\n  return (\n    value\n      // Return the string content of each paragraph in the value's children.\n      .map(n => Node.string(n))\n      // Join them all with line breaks denoting paragraphs.\n      .join('\\n')\n  )\n}\n\n// Define a deserializing function that takes a string and returns a value.\nconst deserialize = (string: any): Node[] => {\n  // Return a value array of children derived by splitting the string.\n  return string.split('\\n').map((line: string) => {\n    return {\n      children: [{ text: line }],\n    }\n  })\n}\n\nexport default NoteEditor","import fetch from \"isomorphic-fetch\";\nimport { Dropbox } from \"dropbox\";\nimport { State, Snapshot } from \"./model\";\n\n/**\n * This code is based on the dropbox API examples:\n * https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/auth/index.html\n */\n\nconst DROPBOX_APP_KEY = \"31ybvx3rsag1cih\";\nconst CLOUD_PATH = \"/database.json\";\nconst ACCESS_TOKEN_COOKIE = \"dropbox_access_token\"\n\n// SOURCE: https://github.com/dropbox/dropbox-sdk-js/blob/master/examples/javascript/utils.js\nfunction parseQueryString(str: string) {\n  var ret = Object.create(null);\n\n  if (typeof str !== \"string\") {\n    return ret;\n  }\n\n  str = str.trim().replace(/^(\\?|#|&)/, \"\");\n\n  if (!str) {\n    return ret;\n  }\n\n  str.split(\"&\").forEach(function (param) {\n    var parts = param.replace(/\\+/g, \" \").split(\"=\");\n    // Firefox (pre 40) decodes `%3D` to `=`\n    // https://github.com/sindresorhus/query-string/pull/37\n    var key = parts.shift();\n    var val = parts.length > 0 ? parts.join(\"=\") : undefined;\n\n    key = decodeURIComponent(key!);\n\n    // missing `=` should be `null`:\n    // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n    var val2 = val === undefined ? null : decodeURIComponent(val);\n\n    if (ret[key] === undefined) {\n      ret[key] = val2;\n    } else if (Array.isArray(ret[key])) {\n      ret[key].push(val2);\n    } else {\n      ret[key] = [ret[key], val2];\n    }\n  });\n\n  return ret;\n}\n\nfunction readBlob(blob: Blob): Promise<string | ArrayBuffer> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = function (evt) {\n        if (evt && evt.target && evt.target.result) {\n          resolve(evt.target.result);\n        } else {\n          reject(\n            \"Blob had an unexpected format: blob.target.result is undefined\\n\" +\n              evt\n          );\n        }\n      };\n      reader.onerror = function (err) {\n        reject(err);\n      };\n      reader.readAsText(blob);\n    });\n  }\n\n// Fetch the access token from local storage, or else check if\n// it is in the URL as a result of OAuth\nfunction getAccessToken() {\n  const cached_token = localStorage.getItem(ACCESS_TOKEN_COOKIE)\n  if (cached_token !== null) {\n    return cached_token;\n  }\n\n  const url_token = parseQueryString(window.location.hash).access_token\n  if (url_token) {\n    localStorage.setItem(ACCESS_TOKEN_COOKIE, url_token)\n  }\n  return url_token\n}\n\nexport function isAuthenticated() {\n  return !!getAccessToken();\n}\n\nconst dbx = isAuthenticated() \n    ? new Dropbox({ fetch, accessToken: getAccessToken() })\n    : new Dropbox({ fetch, clientId: DROPBOX_APP_KEY });\n\nasync function upload(state: State): Promise<void> {\n    try {\n        state.dirty = false;\n        const result = await dbx.filesUpload({\n            contents: JSON.stringify(state.snapshot),\n            path: CLOUD_PATH,\n            mode: { \".tag\": \"overwrite\" },\n            mute: true,\n        })\n        console.log(\"Upload successful\");\n        console.log(result);\n    }\n    catch (e) {\n        console.error(\"Upload failed!\");\n        console.error(e);\n        state.dirty = true;\n    }\n}\n\nasync function download(): Promise<Snapshot | null> {\n    try {\n        const result   = await dbx.filesDownload({ path: CLOUD_PATH }) as any;\n        const response = await readBlob(result.fileBlob) as string\n        const snapshot = JSON.parse(response) as Snapshot;\n        return snapshot;\n    } catch (err) {\n        console.error(\"Error fetching data from cloud:\");\n        console.error(err);\n        return null;\n    }\n}\n\nexport type AuthenticatedCloud = {\n    isAuthenticated: true,\n    upload: (state: State) => Promise<void>,\n    download: () => Promise<Snapshot | null>\n}\n\nexport type UnauthenticatedCloud = {\n    isAuthenticated: false,\n    authenticationURL: string\n}\n\nexport type Cloud = AuthenticatedCloud | UnauthenticatedCloud\n\nconst Cloud: Cloud = isAuthenticated() ? \n    {\n        isAuthenticated: true,\n        upload, download\n    }\n    :\n    {\n        isAuthenticated: false,\n        authenticationURL: dbx.getAuthenticationUrl(window.location.toString())\n    }\n\nexport default Cloud\n\n\n","import React, { useRef, useEffect, useState } from 'react';\nimport ReactDOM from 'react-dom';\nimport ReactMarkdown from 'react-markdown';\nimport RemarkMathPlugin from 'remark-math';\nimport RemarkHighlightPlugin from 'remark-highlight.js';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport { BlockMath, InlineMath } from 'react-katex';\nimport Hotkeys from 'react-hot-keys';\nimport './index.scss';\nimport * as serviceWorker from './serviceWorker';\nimport { State, interpretKeypress, Card, Keypress, ID, Index, Note, Snapshot, DB_STRING } from './model';\nimport 'materialize-css/dist/js/materialize.min.js';\nimport 'katex/dist/katex.min.css';\nimport NoteEditor from './NoteEditor';\nimport Dropbox, { AuthenticatedCloud } from './cloud';\nimport { getFeatures, removeFormatting } from './search';\nimport logo from './logo.jpeg';\n\n\ntype CardProps = { card: Card, id: ID, state: State, isFocused: boolean, isSelected: boolean }\ntype PreviewProps = { card: Card, id: ID, state: State }\n\nfunction onKeyDown(e: React.KeyboardEvent) {\n  if (state) {\n    if (e.key === 'Escape') {\n      state.mode = 'viewing'\n      state.save()\n      render()\n    }\n  }\n}\n\nfunction scrollToElement(el : HTMLElement) {\n  el.scrollIntoView({behavior: \"smooth\", block: \"center\"})\n}\n\nfunction EditNote(\n  props: { note: Note, id: ID }\n): JSX.Element {\n\n  const {note, id} = props\n  const ref: React.MutableRefObject<HTMLTextAreaElement | null> = useRef(null)\n\n  if (ref.current)\n    scrollToElement(ref.current)\n\n  return (\n    <div className=\"card-panel z-depth-3 edited-note\">\n      <NoteEditor note={note} id={id} updateNote={updateNote} onKeyDown={onKeyDown} />\n    </div>\n  )\n}\n\nconst MarkdownRenderers: ReactMarkdown.Renderers = {\n  math: ({value}) => <BlockMath>{value}</BlockMath>,\n  inlineMath: ({ value }) => <InlineMath>{value}</InlineMath>,\n  code: ({language, value}) => <SyntaxHighlighter language={language} style={docco}>{value}</SyntaxHighlighter>\n}\n\nfunction ViewNote(\n  props: { card: Note, id: ID, state: State, isFocused: boolean, isSelected: boolean }\n): JSX.Element {\n\n  const ifFocused = props.isFocused ? \"z-depth-3\" : \"\";\n  const ifSelected = props.isSelected ? \"blue lighten-5\" : \"\";\n  const className = [\"card-panel\", ifFocused, ifSelected].join(\" \");\n\n  const ref: React.MutableRefObject<HTMLDivElement | null> = useRef(null)\n\n  useEffect( () => {\n    if (ref.current && props.isFocused) {\n      console.log(\"Scrolling to\", props.id);\n\n      (async () => {\n        const text = await removeFormatting(props.card.contents)\n        console.log(\"Contents:\", getFeatures(text))\n      })()\n\n      setTimeout(() => {\n        scrollToElement(ref.current!)\n      }, 20)\n    }\n  })\n\n  return (\n    <div className={className} ref={ref}>\n      <ReactMarkdown \n        source={props.card.contents}\n        plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n        renderers={MarkdownRenderers as any}\n      />\n    </div>\n  )\n}\n\nfunction RenderCard(props: CardProps): JSX.Element {\n  const {card, id, state, isFocused} = props;\n\n  if (card.type === 'index') {\n    return (\n      <div>\n        {`Index: (${card.contents.length} cards)`}\n      </div>\n    )\n  }\n  else {\n\n    if (isFocused && state.mode === 'editing') {\n      return (\n        <EditNote note={card} id={id} />\n      )\n    }\n    else {\n      return (\n        <ViewNote {...props} card={card} />\n      )\n    }\n  }\n}\n\nfunction CardPreview({card, id, state}: PreviewProps): JSX.Element {\n  if (card.type === 'index') {\n    return (\n      <div className=\"card-panel truncate\">\n        {`Index: (${card.contents.length} cards)`}\n      </div>\n    )\n  }\n  else {\n    const words = card.contents.split(\" \");\n    const preview = words.length > 20 \n      ? words.slice(0,20).join(\" \") + \"...\" \n      : card.contents;\n\n    return (\n      <div className=\"card-panel\">\n        <ReactMarkdown \n          source={preview}\n          plugins={[RemarkMathPlugin, RemarkHighlightPlugin]}\n          renderers={MarkdownRenderers as any}\n        />\n      </div>\n    )\n  }\n}\n\nfunction Search({state}: {state: State | null}): JSX.Element {\n  const [query, setQuery] = useState(\"\");\n  const ref: React.MutableRefObject<HTMLInputElement | null> = useRef(null)\n\n  function onSubmit(event: React.SyntheticEvent) {\n    event.preventDefault()\n    if (state) {\n      state.search(query)\n      render()\n      if (ref.current) ref.current.blur()\n    }\n  }\n\n  return (\n    <form className=\"input-field\" onSubmit={onSubmit}>\n      <i className=\"material-icons prefix\">search</i>\n      <input id=\"icon_prefix\" type=\"text\" ref={ref}\n        onChange={ e => setQuery(e.target.value) } />\n      <label htmlFor=\"icon_prefix\">Search</label>\n    </form>\n  )\n}\n\nfunction Editor({state}: {state: State | null}): JSX.Element {\n\n  if (state === null) {\n    return (\n      <div className=\"row\">\n        <div className=\"col s3 offset-s4\">\n          <div className=\"card-panel valign-wrapper\">\n            <b className=\"center-align\">Loading...</b>\n          </div>\n        </div>\n      </div>\n    )\n  }\n\n  const cards = state.currentIndex.contents\n  const focusedID = cards[state.focus]\n  const outgoing = state.db[focusedID + \"-outgoing\"] as Index | undefined\n  const incoming = state.db[focusedID + \"-incoming\"] as Index | undefined\n\n  return (\n    <div className=\"row\">\n      <div className=\"pinned col l3 offset-l1 m3 hide-on-small-only\">\n        <img src={logo} style={{display: \"block\", margin: \"auto\", width: \"50%\"}} />\n        {incoming && incoming.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} id={id} state={state} />\n        })}\n      </div>\n      <div className=\"col l4 offset-l4 m6 offset-m3 s10 offset-s1\" style={{marginBottom: \"20em\"}}> \n        <Search state={state} />\n        {\n          Dropbox.isAuthenticated ||\n          <div className=\"card-panel\">\n            <a href={Dropbox.authenticationURL}>Sign in to Dropbox</a>\n          </div>  \n        }\n        {cards.map(function (id: ID, i: number) {\n            const card = state.db[id]\n            const isFocused = state.focus === i\n            const isSelected = state.mode === 'selecting' &&\n              ((state.focus <= i && i <= state.selection!) ||\n              (state.focus >= i && i >= state.selection!))\n\n\n            return <RenderCard id={id} card={card} key={i} state={state} isFocused={isFocused} isSelected={isSelected} />\n        })}\n      </div>\n      <div className=\"pinned col l3 offset-l8 m3 offset-m9 hide-on-small-only\">\n        {outgoing && outgoing.contents.map(function (id: ID, i: number) {\n            return <CardPreview key={i} card={state.db[id]} id={id} state={state} />\n        })}\n      </div>\n    </div>\n  )\n}\n\nconst keymap : { [key: string] : Keypress} = {\n  'Enter': 'enter',\n  'command+c': 'copy',\n  'command+x': 'cut',\n  'command+v': 'paste',\n  'command+z': 'undo',\n  'command+shift+z': 'redo',\n  'Space': 'space',\n  'right': 'right',\n  'left': 'left',\n  'up': 'up',\n  'down': 'down',\n  'Escape': 'escape',\n  'Backspace': 'backspace',\n  'shift+down': 'shift+down',\n  'shift+up': 'shift+up',\n  // VIM keybindings\n  'j': 'down',\n  'k': 'up',\n  'h': 'left',\n  'l': 'right',\n  'u': 'undo',\n  'ctrl+r': 'redo',\n  'y': 'copy',\n  'p': 'paste',\n  'x': 'cut',\n  'd': 'backspace',\n  'i': 'enter',\n  'a': 'space'\n}\n\nconst boundKeys = Object.keys(keymap).join(\",\")\n\nfunction App() {\n  return (\n    <Hotkeys\n      keyName={boundKeys}\n      onKeyDown={handleKey}\n    >\n      <Editor state={state}/>\n    </Hotkeys>\n  );\n}\n\n\n\nlet state : State | null = null;\n\n// Periodically upload state to Dropbox\n\nif (Dropbox.isAuthenticated) {\n  setInterval(() => {\n    if (state !== null && state.dirty)\n      (Dropbox as AuthenticatedCloud).upload(state)\n  }, 10000)\n}\n\n\n// Initialize state, checking Dropbox and localStorage\n\n(async function () {\n  const cloudSnapshot = Dropbox.isAuthenticated ? await Dropbox.download() : null\n  cloudSnapshot && console.log(\"Got cloud snapshot:\", cloudSnapshot)\n\n  const text = localStorage.getItem(DB_STRING)\n  const localSnapshot = text ? JSON.parse(text) as Snapshot : null\n  console.log(\"Got snapshot from localstorage:\", localSnapshot)\n\n  // No previous work found... Start in the initial state.\n  if (localSnapshot === null && cloudSnapshot === null) {\n    state = new State(null);\n  }\n  // Cloud backup found, with no local save. Must be logging in on a new browser or cleared the cache.\n  else if (localSnapshot === null && cloudSnapshot !== null) {\n    state = new State(cloudSnapshot);\n  }\n  // If a local copy is found with no cloud backup, then load that local state.\n  else if (localSnapshot !== null && cloudSnapshot === null) {\n    state = new State(localSnapshot);\n  }\n  // At this point we know that both a local snapshot and a cloud snapshot exist.\n  // Load whichever one has the more recent time stamp.\n  else {\n    state = (localSnapshot!.timestamp < cloudSnapshot!.timestamp) \n      ? new State(cloudSnapshot) \n      : new State(localSnapshot);\n  }\n\n  render();\n\n})()\n\n\nfunction handleKey(key: string, event: any) {\n  if (state) {\n    // Prevent the default refresh event under WINDOWS system\n    event.preventDefault() \n    console.log(keymap[key]) \n    interpretKeypress(keymap[key], state);\n    console.log(state)\n    render()\n  }\n}; \n\nfunction updateNote(id : ID, contents : string) {\n  if (state) {\n    if (state.updateNote(id, contents)) {\n      render()\n    }\n    else {\n      console.error(`Cannot update card ${id}: not a note`)\n    }\n  }\n}\n\nfunction render() {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App />\n    </React.StrictMode>,\n    document.getElementById('root')\n  );  \n}\n\nrender()\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.register();\n"],"sourceRoot":""}